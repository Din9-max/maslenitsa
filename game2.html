<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>–ë–∞—à–Ω—è –∏–∑ –±–ª–∏–Ω–æ–≤</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; -webkit-tap-highlight-color: transparent; }
        body {
            font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            overflow: hidden; height: 100vh; width: 100vw;
            display: flex; flex-direction: column; align-items: center; color: #333;
        }
        h1 {
            position: absolute; top: 15px; width: 100%; text-align: center;
            color: #ff6b6b; z-index: 5; font-size: 24px; pointer-events: none;
            text-shadow: 2px 2px 0px #fff;
        }
        #game-container {
            width: 100%; height: 100%; position: relative; overflow: hidden;
            background-color: transparent;
        }
        canvas { display: block; width: 100%; height: 100%; }
        
        #score-container {
            position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9); padding: 5px 25px; border-radius: 50px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1); z-index: 10; display: none;
            pointer-events: none;
        }
        #score { font-size: 32px; font-weight: bold; color: #ff6b6b; }
        
        .modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; justify-content: center; align-items: center; z-index: 100;
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background: white; padding: 30px; border-radius: 20px; text-align: center; width: 85%; max-width: 400px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.3);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        
        h2 { margin-bottom: 15px; color: #333; }
        p { margin-bottom: 25px; color: #666; line-height: 1.5; }
        
        button {
            background: linear-gradient(to right, #ff9e6d, #ff6b6b);
            color: white; border: none; padding: 15px 40px; width: 100%;
            font-size: 18px; font-weight: bold; border-radius: 50px; cursor: pointer;
            box-shadow: 0 10px 20px rgba(255, 107, 107, 0.3);
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }
    </style>
</head>
<body>
    <h1>üçΩÔ∏è –ë–ª–∏–Ω–Ω—ã–π –®–µ—Ñ ü•û</h1>
    
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="score-container"><div id="score">0</div></div>
        
        <div id="start-modal" class="modal">
            <div class="modal-content">
                <h2>–®–µ—Ñ, –ø–æ—Ä–∞ –≥–æ—Ç–æ–≤–∏—Ç—å!</h2>
                <p>–ù–∞–∂–º–∏ –≤ –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç, —á—Ç–æ–±—ã –±—Ä–æ—Å–∏—Ç—å –±–ª–∏–Ω. –ü–æ—Å—Ç—Ä–æ–π —Å–∞–º—É—é –≤—ã—Å–æ–∫—É—é –±–∞—à–Ω—é! üéµ</p>
                <button id="start-btn">–ò–≥—Ä–∞—Ç—å</button>
            </div>
        </div>

        <div id="game-over" class="modal" style="display:none;">
            <div class="modal-content">
                <h2>–û–π, —É–ø–∞–ª–æ! üò±</h2>
                <p>–¢–≤–æ—è –±–∞—à–Ω—è –≤—ã—Å–æ—Ç–æ–π:</p>
                <h1 style="position:relative; top:0; color:#ff6b6b; font-size:64px; margin-bottom: 20px;">
                    <span id="final-score">0</span>
                </h1>
                <button id="restart-btn">–ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞</button>
            </div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∏
    const CONFIG = {
        pancakeHeight: 30,
        startWidth: 200,
        startSpeed: 3,
        cameraScrollSpeed: 0.1
    };

    const COLORS = [
        { c: "#FFB7B2", p: "#FF9E99" }, // –†–æ–∑–æ–≤–∞—Ç—ã–π
        { c: "#FFDAC1", p: "#FFC8A2" }, // –ü–µ—Ä—Å–∏–∫–æ–≤—ã–π
        { c: "#E2F0CB", p: "#C4E09E" }, // –°–∞–ª–∞—Ç–æ–≤—ã–π
        { c: "#B5EAD7", p: "#95DBC0" }, // –ú—è—Ç–Ω—ã–π
        { c: "#C7CEEA", p: "#A8B3DF" }, // –õ–∞–≤–∞–Ω–¥–æ–≤—ã–π
        { c: "#FDCB6E", p: "#E1B12C" }  // –ó–æ–ª–æ—Ç–∏—Å—Ç—ã–π (–∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π)
    ];

    let state = {
        running: false,
        score: 0,
        stack: [],
        current: null, // { x, y, w, colorIdx, dir, speed }
        debris: [],
        particles: [],
        cameraY: 0,
        targetCameraY: 0
    };

    // --- –ê–£–î–ò–û –°–ò–°–¢–ï–ú–ê (FIXED) ---
    let audioCtx = null;
    
    function initAudio() {
        if (!audioCtx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
        }
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    }

    function playTone(freq, type = 'sine', duration = 0.1) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    function playNote(index) {
        // –ü—Ä–æ—Å—Ç–∞—è –ø–µ–Ω—Ç–∞—Ç–æ–Ω–∏–∫–∞
        const scale = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25]; 
        playTone(scale[index % scale.length], 'triangle', 0.3);
    }

    function playFail() {
        playTone(150, 'sawtooth', 0.5);
        playTone(100, 'sawtooth', 0.5);
    }

    // --- –ì–†–ê–§–ò–ö–ê –ò –†–ï–°–ê–ô–ó ---
    function resize() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        // –ï—Å–ª–∏ –∏–≥—Ä–∞ –Ω–µ –∏–¥–µ—Ç, –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –æ–¥–∏–Ω –∫–∞–¥—Ä, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –ø—É—Å—Ç–æ–≥–æ —ç–∫—Ä–∞–Ω–∞
        if (!state.running && state.stack.length > 0) drawFrame();
    }
    window.addEventListener('resize', resize);

    // --- –ò–ì–†–û–í–ê–Ø –õ–û–ì–ò–ö–ê ---
    function resetGame() {
        state.score = 0;
        state.stack = [];
        state.debris = [];
        state.particles = [];
        state.cameraY = 0;
        state.targetCameraY = 0;
        
        // –ë–∞–∑–æ–≤—ã–π –±–ª–∏–Ω (–æ—Å–Ω–æ–≤–∞–Ω–∏–µ)
        const baseWidth = CONFIG.startWidth;
        const startX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
        const startY = (canvas.height / (window.devicePixelRatio || 1)) - 100;

        state.stack.push({
            x: startX,
            y: startY,
            w: baseWidth,
            cIdx: 5 // –ó–æ–ª–æ—Ç–∏—Å—Ç—ã–π
        });

        spawnNext();
        state.running = true;
        
        document.getElementById('score-container').style.display = 'block';
        document.getElementById('start-modal').style.display = 'none';
        document.getElementById('game-over').style.display = 'none';
        scoreEl.innerText = "0";
        
        loop();
    }

    function spawnNext() {
        const top = state.stack[state.stack.length - 1];
        const nextY = top.y - CONFIG.pancakeHeight;
        
        state.current = {
            x: 0, // –°—Ç–∞—Ä—Ç—É–µ—Ç —Å–ª–µ–≤–∞
            y: nextY,
            w: top.w,
            cIdx: Math.floor(Math.random() * COLORS.length),
            dir: 1,
            speed: CONFIG.startSpeed + (state.score * 0.15),
            falling: false
        };
        
        // –ö–∞–º–µ—Ä–∞ —Å–¥–≤–∏–≥–∞–µ—Ç—Å—è –≤–≤–µ—Ä—Ö –∫–∞–∂–¥—ã–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ –±–ª–∏–Ω–æ–≤
        state.targetCameraY = (state.score * CONFIG.pancakeHeight);
    }

    function placePancake() {
        if (!state.current || state.current.falling) return;
        
        const curr = state.current;
        const prev = state.stack[state.stack.length - 1];
        
        // –†–∞–∑–Ω–∏—Ü–∞ –ø–æ–∑–∏—Ü–∏–π
        const delta = curr.x - prev.x;
        const overhang = Math.abs(delta);
        const overlap = prev.w - overhang;

        if (overlap > 0) {
            // –£—Å–ø–µ—Ö (–æ—Ç—Ä–µ–∑–∞–µ–º –ª–∏—à–Ω–µ–µ)
            playNote(state.score);
            state.score++;
            scoreEl.innerText = state.score;
            
            // –ù–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏ —à–∏—Ä–∏–Ω–∞ –æ–±—Ä–µ–∑–∞–Ω–Ω–æ–≥–æ –±–ª–∏–Ω–∞
            let newW = overlap;
            let newX = prev.x + delta / 2;

            // –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å—Ç–µ–∫
            state.stack.push({
                x: newX,
                y: curr.y,
                w: newW,
                cIdx: curr.cIdx
            });

            // –≠—Ñ—Ñ–µ–∫—Ç –æ–±—Ä–µ–∑–∫–∞ (–ø–∞–¥–∞—é—â–∏–π –∫—É—Å–æ–∫)
            const debrisW = overhang;
            let debrisX;
            if (delta > 0) { // –°–≤–µ—Å —Å–ø—Ä–∞–≤–∞
                debrisX = newX + newW/2 + debrisW/2;
            } else { // –°–≤–µ—Å —Å–ª–µ–≤–∞
                debrisX = newX - newW/2 - debrisW/2;
            }
            createDebris(debrisX, curr.y, debrisW, curr.cIdx);
            createParticles(newX, curr.y, COLORS[curr.cIdx].c);

            spawnNext();
        } else {
            // –ü—Ä–æ–º–∞—Ö
            gameOver();
        }
    }

    function createDebris(x, y, w, cIdx) {
        state.debris.push({
            x: x, y: y, w: w, h: CONFIG.pancakeHeight,
            cIdx: cIdx, vy: 0, rot: 0, vr: (Math.random() - 0.5) * 0.2
        });
    }

    function createParticles(x, y, color) {
        for(let i=0; i<10; i++) {
            state.particles.push({
                x: x + (Math.random()-0.5)*40,
                y: y,
                vx: (Math.random()-0.5)*10,
                vy: (Math.random()-0.5)*10,
                life: 1.0,
                color: color
            });
        }
    }

    function gameOver() {
        state.running = false;
        playFail();
        
        // –≠—Ñ—Ñ–µ–∫—Ç –ø–∞–¥–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–≥–æ –±–ª–∏–Ω–∞
        const curr = state.current;
        createDebris(curr.x, curr.y, curr.w, curr.cIdx);
        state.current = null;

        setTimeout(() => {
            document.getElementById('final-score').innerText = state.score;
            document.getElementById('game-over').style.display = 'flex';
            document.getElementById('score-container').style.display = 'none';
        }, 500);
    }

    // --- –ì–õ–ê–í–ù–´–ô –¶–ò–ö–õ ---
    function update() {
        if (!state.running) return;
        
        // –î–≤–∏–∂–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ –±–ª–∏–Ω–∞
        if (state.current) {
            const limitX = (canvas.width / (window.devicePixelRatio || 1));
            state.current.x += state.current.speed * state.current.dir;
            
            // –û—Ç—Å–∫–æ–∫ –æ—Ç –∫—Ä–∞–µ–≤ (—Å –∑–∞–ø–∞—Å–æ–º, —á—Ç–æ–±—ã –Ω–µ —É–ª–µ—Ç–∞–ª –¥–∞–ª–µ–∫–æ)
            if (state.current.x > limitX - 50 && state.current.dir > 0) state.current.dir = -1;
            if (state.current.x < 50 && state.current.dir < 0) state.current.dir = 1;
        }

        // –ü–ª–∞–≤–Ω–∞—è –∫–∞–º–µ—Ä–∞
        state.cameraY += (state.targetCameraY - state.cameraY) * 0.1;
    }

    function drawFrame() {
        const width = canvas.width / (window.devicePixelRatio || 1);
        const height = canvas.height / (window.devicePixelRatio || 1);
        
        ctx.clearRect(0, 0, width, height);

        ctx.save();
        // –°–º–µ—â–∞–µ–º –º–∏—Ä –≤–Ω–∏–∑ –ø–æ –º–µ—Ä–µ —Ä–æ—Å—Ç–∞ –±–∞—à–Ω–∏
        ctx.translate(0, state.cameraY);

        // –†–∏—Å—É–µ–º —Å—Ç–æ–ª (—Ñ–æ–Ω –ø–æ–¥ –±–∞—à–Ω–µ–π)
        const tableY = state.stack[0] ? state.stack[0].y + CONFIG.pancakeHeight/2 : height;
        ctx.fillStyle = "#8d5524";
        ctx.fillRect(0, tableY, width, height);

        // –†–∏—Å—É–µ–º —Å—Ç–µ–∫
        state.stack.forEach(p => {
            drawPancake(p.x, p.y, p.w, p.cIdx);
        });

        // –†–∏—Å—É–µ–º –æ–±–ª–æ–º–∫–∏
        for (let i = state.debris.length - 1; i >= 0; i--) {
            let d = state.debris[i];
            d.vy += 0.8; // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
            d.y += d.vy;
            d.rot += d.vr;
            
            ctx.save();
            ctx.translate(d.x, d.y);
            ctx.rotate(d.rot);
            drawPancake(0, 0, d.w, d.cIdx);
            ctx.restore();

            if (d.y > height + state.cameraY + 100) state.debris.splice(i, 1);
        }

        // –†–∏—Å—É–µ–º —Ç–µ–∫—É—â–∏–π
        if (state.current) {
            drawPancake(state.current.x, state.current.y, state.current.w, state.current.cIdx);
        }

        // –ß–∞—Å—Ç–∏—Ü—ã
        for (let i = state.particles.length - 1; i >= 0; i--) {
            let p = state.particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.05;
            
            ctx.globalAlpha = Math.max(0, p.life);
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
            ctx.fill();
            
            if (p.life <= 0) state.particles.splice(i, 1);
        }
        ctx.globalAlpha = 1;

        ctx.restore();
    }

    function drawPancake(x, y, w, cIdx) {
        const color = COLORS[cIdx % COLORS.length];
        const h = CONFIG.pancakeHeight;
        
        // –¢–µ–Ω—å/–ë–æ–∫–æ–≤–∏–Ω–∞
        ctx.fillStyle = color.p;
        ctx.beginPath();
        ctx.roundRect(x - w/2, y - h/2 + 5, w, h, 10);
        ctx.fill();

        // –í–µ—Ä—Ö–Ω—è—è —á–∞—Å—Ç—å
        ctx.fillStyle = color.c;
        ctx.beginPath();
        ctx.roundRect(x - w/2, y - h/2, w, h-5, 10);
        ctx.fill();
        
        // –ë–ª–∏–∫
        ctx.fillStyle = "rgba(255,255,255,0.2)";
        ctx.beginPath();
        ctx.ellipse(x - w/4, y - h/2 + 5, w/4, 3, 0, 0, Math.PI*2);
        ctx.fill();
    }

    function loop() {
        if (!state.running && state.debris.length === 0) return;
        update();
        drawFrame();
        if (state.running || state.debris.length > 0) requestAnimationFrame(loop);
    }

    // --- –í–í–û–î –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø ---
    function handleInput(e) {
        if (e.type !== 'click' && e.cancelable) e.preventDefault(); // –ë–ª–æ–∫–∏—Ä—É–µ–º –∑—É–º
        if (state.running) {
            placePancake();
        }
    }

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–Ω–æ–ø–æ–∫
    document.getElementById('start-btn').addEventListener('click', () => {
        initAudio(); // –í–∞–∂–Ω–æ: –∑–≤—É–∫ –∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç—Å—è –∑–¥–µ—Å—å
        resize(); // –û–±–Ω–æ–≤–ª—è–µ–º —Ä–∞–∑–º–µ—Ä –ø–µ—Ä–µ–¥ —Å—Ç–∞—Ä—Ç–æ–º
        resetGame();
    });

    document.getElementById('restart-btn').addEventListener('click', () => {
        resetGame();
    });

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∏–≥—Ä—ã (—ç–∫—Ä–∞–Ω)
    const gameArea = document.getElementById('game-container');
    gameArea.addEventListener('mousedown', handleInput);
    gameArea.addEventListener('touchstart', handleInput, { passive: false });
    
    // –ü–µ—Ä–≤—ã–π —Ä–µ—Å–∞–π–∑
    resize();

</script>
</body>
</html>
