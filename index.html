<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>‚òÄÔ∏è –ë–õ–ò–ù–ù–´–ô –®–£–¢–ï–†</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body { 
            height: 100vh; height: 100dvh; width: 100vw; 
            overflow: hidden; background: #fad0a5; font-family: sans-serif; 
            position: fixed;
        }
        .game-wrapper {
            position: relative; width: 100%; height: 100%;
            max-width: 500px; margin: 0 auto;
            display: flex; flex-direction: column;
            background: #fff4e6; /* –ó–∞–ø–∞—Å–Ω–æ–π —Ñ–æ–Ω */
            border-left: 2px solid #d2691e; border-right: 2px solid #d2691e;
        }
        .header {
            flex: 0 0 auto; height: 70px; margin: 10px;
            background: #fff; border: 3px solid #c28a3b;
            border-radius: 15px; display: flex; justify-content: space-around; align-items: center;
        }
        .stat-item { text-align: center; }
        .stat-label { font-size: 10px; font-weight: bold; color: #7b3f00; }
        .stat-value { font-size: 18px; font-weight: 900; color: #a0522d; }
        
        .canvas-container { flex: 1; position: relative; width: 100%; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; background: rgba(255,255,255,0.1); }

        .modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center;
            z-index: 100;
        }
        .modal-content {
            background: white; padding: 30px; border-radius: 20px; text-align: center; width: 80%;
        }
        button {
            background: #f57c00; color: white; border: none; padding: 15px 30px;
            font-size: 20px; border-radius: 30px; margin-top: 20px; font-weight: bold;
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div class="game-wrapper">
        <div class="header">
            <div class="stat-item">
                <div class="stat-label">ü•û –°–ß–ï–¢</div>
                <div class="stat-value" id="score">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">üèÜ –†–ï–ö–û–†–î</div>
                <div class="stat-value" id="high-score">0</div>
            </div>
        </div>

        <div class="canvas-container" id="container">
            <canvas id="gameCanvas"></canvas>
            <div id="modal" class="modal">
                <div class="modal-content">
                    <h1>‚òÄÔ∏è –ú–ê–°–õ–ï–ù–ò–¶–ê</h1>
                    <p>–°—Ç—Ä–µ–ª—è–π –ø–æ –±–ª–∏–Ω–∞–º!</p>
                    <button id="start-btn">–ò–ì–†–ê–¢–¨</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');

        let RADIUS, DIAMETER, cols, rows, SPEED;
        let grid = [];
        let score = 0;
        let state = 'MENU';
        let shooter = { x: 0, y: 0, type: 0, next: 0, ball: null };
        let isAiming = false, aimAngle = -Math.PI / 2;

        const TYPES = [
            { c: '#FFD700', b: '#B8860B', img: 'honey.png' },
            { c: '#FF69B4', b: '#C71585', img: 'Strawberry.png' },
            { c: '#F0F8FF', b: '#4682B4', img: 'milk.png' },
            { c: '#FFFACD', b: '#DAA520', img: 'cheese.png' },
            { c: '#8B4513', b: '#5D2E0A', img: 'meat.png' }
        ];

        const images = TYPES.map(t => {
            const img = new Image();
            img.src = t.img;
            return img;
        });

        function resize() {
            const container = document.getElementById('container');
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;
            
            cols = 8;
            DIAMETER = canvas.width / cols;
            RADIUS = DIAMETER / 2;
            rows = Math.floor(canvas.height / DIAMETER);
            
            shooter.x = canvas.width / 2;
            shooter.y = canvas.height - (DIAMETER * 1.5);
            SPEED = canvas.height * 0.03;

            // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏–∏ –≤ —Å–µ—Ç–∫–µ –ø—Ä–∏ —Ä–µ—Å–∞–π–∑–µ
            for(let r=0; r<grid.length; r++) {
                for(let c=0; c<cols; c++) {
                    if(grid[r][c]) {
                        grid[r][c].x = c * DIAMETER + RADIUS;
                        grid[r][c].y = r * DIAMETER + RADIUS;
                    }
                }
            }
        }

        function init() {
            score = 0;
            scoreEl.innerText = score;
            grid = [];
            for (let r = 0; r < rows; r++) {
                grid[r] = new Array(cols).fill(null);
            }
            // –ó–∞–ø–æ–ª–Ω—è–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ 4 —Ä—è–¥–∞
            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < cols; c++) {
                    if (Math.random() > 0.3) {
                        grid[r][c] = {
                            type: Math.floor(Math.random() * TYPES.length),
                            x: c * DIAMETER + RADIUS,
                            y: r * DIAMETER + RADIUS
                        };
                    }
                }
            }
            shooter.type = Math.floor(Math.random() * TYPES.length);
            shooter.next = Math.floor(Math.random() * TYPES.length);
            state = 'PLAYING';
            document.getElementById('modal').classList.add('hidden');
        }

        function drawBall(x, y, type, r = RADIUS) {
            ctx.save();
            ctx.beginPath();
            ctx.arc(x, y, r - 3, 0, Math.PI * 2);
            
            // –°–Ω–∞—á–∞–ª–∞ —Ñ–æ–Ω (–µ—Å–ª–∏ –∫–∞—Ä—Ç–∏–Ω–∫–∞ –Ω–µ –ø—Ä–æ–≥—Ä—É–∑–∏—Ç—Å—è)
            ctx.fillStyle = TYPES[type].c;
            ctx.fill();

            // –ö–∞—Ä—Ç–∏–Ω–∫–∞
            if (images[type].complete && images[type].naturalWidth > 0) {
                ctx.clip();
                ctx.drawImage(images[type], x - r, y - r, r * 2, r * 2);
            }

            ctx.strokeStyle = TYPES[type].b;
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
        }

        function update() {
            if (state !== 'PLAYING') return;

            if (shooter.ball) {
                const b = shooter.ball;
                b.x += b.vx;
                b.y += b.vy;

                // –°—Ç–µ–Ω—ã
                if (b.x < RADIUS || b.x > canvas.width - RADIUS) b.vx *= -1;

                // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å –ø–æ—Ç–æ–ª–∫–æ–º
                if (b.y < RADIUS) {
                    snap(b);
                } else {
                    // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å –¥—Ä—É–≥–∏–º–∏ –±–ª–∏–Ω–∞–º–∏
                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            const cell = grid[r][c];
                            if (cell && Math.hypot(b.x - cell.x, b.y - cell.y) < DIAMETER * 0.85) {
                                snap(b);
                                return;
                            }
                        }
                    }
                }
                
                // –í—ã–ª–µ—Ç –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã (–∑–∞—â–∏—Ç–∞ –æ—Ç –±–∞–≥–æ–≤)
                if(b.y < -RADIUS || b.y > canvas.height) shooter.ball = null;
            }
        }

        function snap(b) {
            let c = Math.round((b.x - RADIUS) / DIAMETER);
            let r = Math.round((b.y - RADIUS) / DIAMETER);
            c = Math.max(0, Math.min(c, cols - 1));
            r = Math.max(0, Math.min(r, rows - 1));

            // –ò—â–µ–º –±–ª–∏–∂–∞–π—à—É—é —Å–≤–æ–±–æ–¥–Ω—É—é —è—á–µ–π–∫—É
            if (r >= 0 && r < rows) {
                if (grid[r][c]) r++; 
                if (r < rows && !grid[r][c]) {
                    grid[r][c] = { 
                        type: b.type, 
                        x: c * DIAMETER + RADIUS, 
                        y: r * DIAMETER + RADIUS 
                    };
                    checkMatch(r, c, b.type);
                }
            }

            shooter.ball = null;
            shooter.type = shooter.next;
            shooter.next = Math.floor(Math.random() * TYPES.length);
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—Ä–æ–∏–≥—Ä—ã—à (–µ—Å–ª–∏ –±–ª–∏–Ω—ã —Å–ª–∏—à–∫–æ–º –Ω–∏–∑–∫–æ)
            if (grid[rows - 2].some(cell => cell !== null)) {
                state = 'MENU';
                document.getElementById('modal').classList.remove('hidden');
            }
        }

        function checkMatch(r, c, type) {
            const matches = [];
            const visited = new Set();
            const queue = [[r, c]];
            visited.add(`${r},${c}`);

            while (queue.length > 0) {
                const [currR, currC] = queue.shift();
                matches.push([currR, currC]);

                [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                    const nr = currR + dr, nc = currC + dc;
                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols &&
                        grid[nr][nc] && grid[nr][nc].type === type &&
                        !visited.has(`${nr},${nc}`)) {
                        visited.add(`${nr},${nc}`);
                        queue.push([nr, nc]);
                    }
                });
            }

            if (matches.length >= 3) {
                matches.forEach(([mr, mc]) => grid[mr][mc] = null);
                score += matches.length * 10;
                scoreEl.innerText = score;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // –°–µ—Ç–∫–∞
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (grid[r][c]) drawBall(grid[r][c].x, grid[r][c].y, grid[r][c].type);
                }
            }

            // –õ–∏–Ω–∏—è –ø—Ä–∏—Ü–µ–ª–∞
            if (isAiming && !shooter.ball && state === 'PLAYING') {
                ctx.beginPath();
                ctx.setLineDash([5, 10]);
                ctx.moveTo(shooter.x, shooter.y);
                ctx.lineTo(shooter.x + Math.cos(aimAngle) * 100, shooter.y + Math.sin(aimAngle) * 100);
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // –ü—É—à–∫–∞
            if (state === 'PLAYING') {
                drawBall(shooter.x, shooter.y, shooter.type);
                // –ü—Ä–µ–≤—å—é —Å–ª–µ–¥—É—é—â–µ–≥–æ
                drawBall(shooter.x + 40, shooter.y + 10, shooter.next, RADIUS * 0.6);
            }

            // –°–Ω–∞—Ä—è–¥
            if (shooter.ball) {
                drawBall(shooter.ball.x, shooter.ball.y, shooter.ball.type);
            }

            requestAnimationFrame(() => {
                update();
                draw();
            });
        }

        function handleInput(e) {
            if (state !== 'PLAYING') return;
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || e.touches?.[0].clientX) - rect.left;
            const y = (e.clientY || e.touches?.[0].clientY) - rect.top;
            aimAngle = Math.atan2(y - shooter.y, x - shooter.x);
        }

        canvas.addEventListener('pointerdown', (e) => {
            isAiming = true;
            handleInput(e);
        });
        canvas.addEventListener('pointermove', (e) => {
            if (isAiming) handleInput(e);
        });
        canvas.addEventListener('pointerup', () => {
            if (isAiming && !shooter.ball && state === 'PLAYING') {
                shooter.ball = {
                    x: shooter.x,
                    y: shooter.y,
                    vx: Math.cos(aimAngle) * SPEED,
                    vy: Math.sin(aimAngle) * SPEED,
                    type: shooter.type
                };
            }
            isAiming = false;
        });

        document.getElementById('start-btn').onclick = init;
        window.addEventListener('resize', resize);

        resize();
        draw(); // –ó–∞–ø—É—Å–∫–∞–µ–º —Ü–∏–∫–ª –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
    </script>
</body>
</html>
