<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>‚òÄÔ∏è –ë–õ–ò–ù–ù–´–ô –®–£–¢–ï–† ¬∑ –ú–∞—Å–ª–µ–Ω–∏—Ü–∞</title>
    <style>
        /* ===== –ú–û–ë–ò–õ–¨–ù–ê–Ø –ë–ê–ó–ê ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none; /* –û—Ç–∫–ª—é—á–∞–µ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∂–µ—Å—Ç—ã –±—Ä–∞—É–∑–µ—Ä–∞ */
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-family: 'Segoe UI', 'Roboto', 'Helvetica', sans-serif;
        }

        body {
            /* dvh —Ä–µ—à–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—É —Å –ø—Ä—ã–≥–∞—é—â–µ–π –∞–¥—Ä–µ—Å–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π –Ω–∞ iOS/Android */
            height: 100vh;
            height: 100dvh; 
            width: 100vw;
            overflow: hidden;
            background: radial-gradient(circle at 20% 30%, #fbe9d2, #fad0a5);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* –§–æ–Ω —Å –ª—É—á–∞–º–∏ */
        .sky-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: linear-gradient(145deg, #ffdab9 0%, #ffe5b4 40%, #ffd6a5 100%);
            overflow: hidden;
        }

        .sun-rays {
            position: absolute;
            top: -10vw;
            left: -10vw;
            width: 60vw;
            height: 60vw;
            background: radial-gradient(circle, #ffdd77 0%, rgba(255, 221, 119, 0) 70%);
            border-radius: 50%;
            opacity: 0.5;
            animation: spin 40s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* ===== –ò–ì–†–û–í–û–ô –ö–û–ù–¢–ï–ô–ù–ï–† ===== */
        .game-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            /* –ù–∞ –¥–µ—Å–∫—Ç–æ–ø–µ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —à–∏—Ä–∏–Ω—É, –Ω–∞ –º–æ–±–∏–ª—å–Ω–æ–º - –Ω–∞ –≤–µ—Å—å —ç–∫—Ä–∞–Ω */
            max-width: 500px; 
            display: flex;
            flex-direction: column;
            background: linear-gradient(rgba(255, 222, 191, 0.9), rgba(255, 228, 204, 0.9)),
                        url('—Ñ–æ–Ω_2.jpeg') center/cover no-repeat;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        /* –ï—Å–ª–∏ —ç–∫—Ä–∞–Ω –±–æ–ª—å—à–æ–π, –¥–æ–±–∞–≤–ª—è–µ–º —Ä–∞–º–∫—É */
        @media (min-width: 501px) {
            .game-wrapper {
                height: 95dvh;
                border-radius: 30px;
                border: 6px solid #d2691e;
            }
        }

        /* ===== –®–ê–ü–ö–ê ===== */
        .header {
            flex: 0 0 auto;
            height: 90px;
            background: linear-gradient(165deg, #ffecd2, #fcdec2);
            border-bottom: 6px solid #c28a3b;
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            box-shadow: 0 5px 15px rgba(110, 55, 0, 0.2);
            z-index: 20;
            padding: 5px;
            border-radius: 0 0 25px 25px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255, 245, 220, 0.6);
            padding: 5px 10px;
            border-radius: 15px;
            border: 2px solid #d2691e;
            min-width: 70px;
        }

        .stat-label {
            font-size: 10px;
            color: #7b3f00;
            font-weight: 800;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 900;
            color: #a0522d;
        }

        /* –ñ–∏–∑–Ω–∏ */
        .lives-row {
            display: flex;
            gap: 4px;
            margin-top: 2px;
        }
        .life-dot {
            width: 14px;
            height: 14px;
            background: radial-gradient(circle at 30% 30%, #ffc068, #d41a1a);
            border-radius: 50%;
            border: 1px solid #9c5a2c;
            transition: 0.3s;
        }
        .life-dot.lost {
            background: #ccc;
            transform: scale(0.6);
            opacity: 0.5;
            border-color: #888;
        }

        /* ===== –ö–ù–û–ü–ö–ò –£–ü–†–ê–í–õ–ï–ù–ò–Ø ===== */
        .game-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: none; /* –ß—Ç–æ–±—ã –∫–ª–∏–∫–∏ –ø—Ä–æ—Ö–æ–¥–∏–ª–∏ —Å–∫–≤–æ–∑—å –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä */
            z-index: 50;
        }

        .control-btn {
            width: 55px;
            height: 55px;
            background: radial-gradient(circle at 30% 30%, #ffb347, #e68a2e);
            border: 3px solid #ffe28c;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            box-shadow: 0 6px 0 #9c5a2b, 0 8px 15px rgba(0,0,0,0.3);
            cursor: pointer;
            pointer-events: auto; /* –í–∫–ª—é—á–∞–µ–º –∫–ª–∏–∫–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫ */
            transition: transform 0.1s;
        }
        .control-btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #9c5a2b;
        }
        .control-btn.muted { filter: grayscale(1); }

        /* ===== CANVAS ===== */
        .canvas-container {
            flex: 1;
            position: relative;
            width: 100%;
            overflow: hidden;
            /* –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Ç–µ–Ω—å –¥–ª—è –≥–ª—É–±–∏–Ω—ã */
            box-shadow: inset 0 0 30px rgba(139, 69, 19, 0.2); 
            cursor: crosshair;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* ===== –ú–û–î–ê–õ–¨–ù–´–ï –û–ö–ù–ê ===== */
        .modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(60, 30, 10, 0.75);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.3s;
        }
        .hidden { display: none !important; }

        .modal-content {
            background: linear-gradient(145deg, #fff3e0, #ffecb3);
            padding: 25px;
            border-radius: 30px;
            width: 85%;
            max-width: 320px;
            text-align: center;
            border: 6px solid #ffa000;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            position: relative;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        .modal h1 { color: #d84315; font-size: 28px; margin-bottom: 10px; text-transform: uppercase; text-shadow: 1px 1px 0 #fff; }
        .modal p { color: #5d4037; font-size: 16px; margin-bottom: 15px; font-weight: 600; line-height: 1.4; }

        .big-btn {
            background: linear-gradient(to bottom, #ff9800, #f57c00);
            border: none;
            color: white;
            padding: 15px 30px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 50px;
            box-shadow: 0 6px 0 #e65100, 0 10px 10px rgba(0,0,0,0.2);
            width: 100%;
            margin-top: 10px;
        }
        .big-btn:active { transform: translateY(4px); box-shadow: 0 2px 0 #e65100; }

        /* –°–µ—Ç–∫–∞ –Ω–∞—á–∏–Ω–æ–∫ –≤ –º–µ–Ω—é */
        .flavors-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 15px 0;
            background: rgba(255,255,255,0.4);
            padding: 10px;
            border-radius: 15px;
        }
        .flavor-mini {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .flavor-icon {
            width: 35px; height: 35px;
            border-radius: 50%;
            background-size: cover;
            border: 2px solid #fff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            margin-bottom: 4px;
        }
        .flavor-text { font-size: 10px; font-weight: bold; color: #6d4c41; }
        
        .pause-stats p { font-size: 18px; margin: 8px 0; border-bottom: 1px dashed #d7ccc8; padding-bottom: 5px; }

    </style>
</head>
<body>

    <div class="sky-background"><div class="sun-rays"></div></div>

    <div class="game-wrapper">
        <div class="header">
            <div class="stat-item">
                <span class="stat-label">ü•û –°—á–µ—Ç</span>
                <span class="stat-value" id="score">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">‚ù§Ô∏è –ñ–∏–∑–Ω–∏</span>
                <div class="lives-row" id="lives-container"></div>
            </div>
            <div class="stat-item">
                <span class="stat-label">üèÜ –†–µ–∫–æ—Ä–¥</span>
                <span class="stat-value" id="high-score">0</span>
            </div>
        </div>

        <div class="canvas-container" id="canvas-container">
            <canvas id="gameCanvas"></canvas>
            
            <div id="modal" class="modal">
                <div class="modal-content">
                    <h1 id="modal-title">‚òÄÔ∏è –ú–ê–°–õ–ï–ù–ò–¶–ê</h1>
                    <p id="modal-desc">–°—Ç—Ä–µ–ª—è–π –±–ª–∏–Ω–∞–º–∏, —Å–æ–±–∏—Ä–∞–π –ø–æ 3 –≤ —Ä—è–¥!</p>
                    
                    <div id="flavors-section">
                        <div class="flavors-grid">
                            <div class="flavor-mini"><div class="flavor-icon" style="background-image: url('honey.png'); background-color: #ffd54f"></div><span class="flavor-text">–ú—ë–¥</span></div>
                            <div class="flavor-mini"><div class="flavor-icon" style="background-image: url('Strawberry.png'); background-color: #ef5350"></div><span class="flavor-text">–Ø–≥–æ–¥—ã</span></div>
                            <div class="flavor-mini"><div class="flavor-icon" style="background-image: url('milk.png'); background-color: #fff176"></div><span class="flavor-text">–°–≥—É—â.</span></div>
                            <div class="flavor-mini"><div class="flavor-icon" style="background-image: url('cheese.png'); background-color: #ffca28"></div><span class="flavor-text">–°—ã—Ä</span></div>
                            <div class="flavor-mini"><div class="flavor-icon" style="background-image: url('meat.png'); background-color: #8d6e63"></div><span class="flavor-text">–ú—è—Å–æ</span></div>
                            <div class="flavor-mini"><div class="flavor-icon" style="background: radial-gradient(circle, #333, #000);">üí£</div><span class="flavor-text">–ë–æ–º–±–∞</span></div>
                        </div>
                    </div>
                    
                    <button id="action-btn" class="big-btn">–ò–ì–†–ê–¢–¨</button>
                </div>
            </div>

            <div id="pauseModal" class="modal hidden">
                <div class="modal-content">
                    <h1>‚è∏ –ü–ê–£–ó–ê</h1>
                    <div class="pause-stats">
                        <p>–°—á–µ—Ç: <span id="pauseScore">0</span></p>
                        <p>–ñ–∏–∑–Ω–∏: <span id="pauseLives">0</span></p>
                    </div>
                    <button id="resumeBtn" class="big-btn" style="background: linear-gradient(#66bb6a, #43a047); box-shadow: 0 6px 0 #2e7d32;">–ü–†–û–î–û–õ–ñ–ò–¢–¨</button>
                </div>
            </div>
        </div>

        <div class="game-controls">
            <div id="pauseBtn" class="control-btn" style="font-size: 20px;">‚è∏</div>
            <div id="soundToggle" class="control-btn" style="font-size: 24px;">‚ô¨</div>
        </div>
    </div>

    <script>
        (function(){
            // === –ù–ê–°–¢–†–û–ô–ö–ò –ú–û–ë–ò–õ–¨–ù–û–ô –í–ï–†–°–ò–ò ===
            const canvas = document.getElementById('gameCanvas');
            const container = document.getElementById('canvas-container');
            const ctx = canvas.getContext('2d', { alpha: false }); // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Ä–µ–Ω–¥–µ—Ä–∞

            // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —Ç–µ–ø–µ—Ä—å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ (–∑–∞–≤–∏—Å—è—Ç –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ —ç–∫—Ä–∞–Ω–∞)
            let RADIUS, DIAMETER, SPEED;
            const COLUMNS_MOBILE = 9;  // –ö–æ–ª-–≤–æ –±–ª–∏–Ω–æ–≤ –≤ —à–∏—Ä–∏–Ω—É –Ω–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–µ
            const MAX_LIVES = 5;

            // –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
            const PANCAKE_IMAGES = ['honey.png', 'Strawberry.png', 'milk.png', 'cheese.png', 'meat.png'];
            const BOMB_IMAGE = 'bomb.png';
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ü–≤–µ—Ç–æ–≤ (fallback –µ—Å–ª–∏ –∫–∞—Ä—Ç–∏–Ω–∫–∏ –Ω–µ—Ç)
            const PANCAKE_TYPES = [
                { color: '#FFC107', border: '#FF6F00' }, // –ú—ë–¥
                { color: '#FF5252', border: '#B71C1C' }, // –Ø–≥–æ–¥—ã
                { color: '#FFF59D', border: '#FBC02D' }, // –°–≥—É—â–µ–Ω–∫–∞
                { color: '#FFEB3B', border: '#F57F17' }, // –°—ã—Ä
                { color: '#A1887F', border: '#5D4037' }  // –ú—è—Å–æ
            ];
            const BOMB_TYPE = 99;

            // –ó–∞–≥—Ä—É–∑–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤
            let pancakeImgs = [];
            let bombImg = new Image();
            bombImg.src = BOMB_IMAGE;
            
            PANCAKE_IMAGES.forEach(src => {
                let img = new Image();
                img.src = src;
                pancakeImgs.push(img);
            });

            // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
            let grid = [], particles = [], falling = [];
            let rows = 0, cols = 0, offsetX = 0;
            let score = 0, lives = MAX_LIVES, highScore = localStorage.getItem('blini_hs') || 0;
            let state = 'MENU';
            let shooter = { x: 0, y: 0, curr: 0, next: 0, ball: null };
            
            // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
            let isAiming = false;
            let aimAngle = -Math.PI / 2;
            let soundEnabled = true;

            // === –ê–î–ê–ü–¢–ò–í–ù–û–°–¢–¨ ===
            function resize() {
                const rect = container.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;

                // !–ì–õ–ê–í–ù–û–ï –ò–ó–ú–ï–ù–ï–ù–ò–ï!: –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –±–ª–∏–Ω–∞ –æ—Ç —à–∏—Ä–∏–Ω—ã —ç–∫—Ä–∞–Ω–∞
                // –ù–∞ –º–æ–±–∏–ª—å–Ω–æ–º —Ö–æ—Ç–∏–º ~9 —Å—Ç–æ–ª–±—Ü–æ–≤. –ù–∞ –¥–µ—Å–∫—Ç–æ–ø–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –±–æ–ª—å—à–µ.
                cols = COLUMNS_MOBILE; 
                DIAMETER = Math.floor(canvas.width / cols);
                RADIUS = DIAMETER / 2;
                
                // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –æ—Ç—Å—Ç—É–ø—ã, —á—Ç–æ–±—ã –±—ã–ª–æ –ø–æ —Ü–µ–Ω—Ç—Ä—É
                offsetX = (canvas.width - cols * DIAMETER) / 2;
                rows = Math.floor(canvas.height / DIAMETER) + 1;
                
                // –°–∫–æ—Ä–æ—Å—Ç—å –ø–æ–ª–µ—Ç–∞ —Ç–æ–∂–µ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ —ç–∫—Ä–∞–Ω–∞
                SPEED = canvas.height * 0.035; // –ü—Ä–æ–ª–µ—Ç–∞–µ—Ç —ç–∫—Ä–∞–Ω –∑–∞ ~30 –∫–∞–¥—Ä–æ–≤

                shooter.x = canvas.width / 2;
                shooter.y = canvas.height - RADIUS * 2.5;
            }

            // === –ó–í–£–ö–û–í–û–ô –î–í–ò–ñ–û–ö (Web Audio API) ===
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            
            function playTone(freq, type, duration, vol=0.1) {
                if (!soundEnabled || audioCtx.state === 'suspended') {
                    audioCtx.resume().catch(()=>{});
                    if(!soundEnabled) return;
                }
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValue(0.01, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            }

            const sounds = {
                shoot: () => playTone(600, 'sine', 0.15, 0.1),
                pop: () => playTone(400, 'sine', 0.1, 0.1),
                bomb: () => playTone(100, 'sawtooth', 0.3, 0.2),
                miss: () => playTone(150, 'triangle', 0.3, 0.1)
            };

            // === –õ–û–ì–ò–ö–ê –ò–ì–†–´ ===
            function initGame() {
                resize();
                score = 0;
                lives = MAX_LIVES;
                state = 'PLAYING';
                grid = []; particles = []; falling = [];
                
                // –°–æ–∑–¥–∞–µ–º —Å–µ—Ç–∫—É
                for (let r = 0; r < rows; r++) grid[r] = new Array(cols).fill(null);
                // –ó–∞–ø–æ–ª–Ω—è–µ–º 5 —Ä—è–¥–æ–≤
                for (let r = 0; r < 5; r++) createRow(r);

                shooter.curr = randType();
                shooter.next = randType();
                shooter.ball = null;
                
                updateUI();
                toggleModal('modal', false);
                toggleModal('pauseModal', false);
                
                // –ü—ã—Ç–∞–µ–º—Å—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –∞—É–¥–∏–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
                if (audioCtx.state === 'suspended') audioCtx.resume();
            }

            function createRow(r) {
                for (let c = 0; c < cols; c++) {
                    // –®–∞—Ö–º–∞—Ç–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ –¥–ª—è –ø–ª–æ—Ç–Ω–æ–π —É–ø–∞–∫–æ–≤–∫–∏ (—É–ø—Ä–æ—â–µ–Ω–æ –¥–ª—è –≥—Ä–∏–¥–∞) –∏–ª–∏ —Ä–∞–Ω–¥–æ–º
                    if (Math.random() > 0.3) { // –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø–æ—è–≤–ª–µ–Ω–∏—è –±–ª–∏–Ω–∞
                        addBall(r, c, Math.random() < 0.05 ? BOMB_TYPE : randType());
                    }
                }
            }

            function addBall(r, c, type) {
                if (!grid[r]) return;
                grid[r][c] = {
                    type: type,
                    x: offsetX + c * DIAMETER + RADIUS,
                    y: r * DIAMETER + RADIUS,
                    targetY: r * DIAMETER + RADIUS // –î–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ –ø–∞–¥–µ–Ω–∏—è —Ä—è–¥–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
                };
            }

            function randType() { return Math.floor(Math.random() * PANCAKE_IMAGES.length); }

            function update() {
                if (state !== 'PLAYING') return;

                // –®–∞—Ä –ª–µ—Ç–∏—Ç
                if (shooter.ball) {
                    let b = shooter.ball;
                    // –î–≤–∏–≥–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –º–µ–ª–∫–∏–º–∏ —à–∞–≥–∞–º–∏ –¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç–∏ (Raycasting "–¥–ª—è –±–µ–¥–Ω—ã—Ö")
                    const steps = 5;
                    for (let i = 0; i < steps; i++) {
                        b.x += b.vx / steps;
                        b.y += b.vy / steps;

                        // –°—Ç–µ–Ω–∫–∏
                        if (b.x < RADIUS) { b.x = RADIUS; b.vx *= -1; }
                        if (b.x > canvas.width - RADIUS) { b.x = canvas.width - RADIUS; b.vx *= -1; }
                        
                        // –ü–æ—Ç–æ–ª–æ–∫
                        if (b.y < RADIUS) {
                            b.y = RADIUS;
                            snapBall(b);
                            return;
                        }
                        
                        // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ
                        if (checkCollision(b)) return;
                    }
                    if (b.y > canvas.height + RADIUS) resetShot(); // –£–ª–µ—Ç–µ–ª –≤–Ω–∏–∑
                }

                // –ê–Ω–∏–º–∞—Ü–∏—è —á–∞—Å—Ç–∏—Ü
                particles.forEach((p, i) => {
                    p.x += p.vx; p.y += p.vy; p.life -= 0.03; p.vy += 0.5;
                    if (p.life <= 0) particles.splice(i, 1);
                });

                // –ü–∞–¥–∞—é—â–∏–µ –±–ª–∏–Ω—ã
                falling.forEach((f, i) => {
                    f.x += f.vx; f.y += f.vy; f.vy += 0.8; f.rot += f.rotSpd;
                    if (f.y > canvas.height + DIAMETER) falling.splice(i, 1);
                });
            }

            function checkCollision(b) {
                // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏ –¥–æ –≤—Å–µ—Ö –±–ª–∏–Ω–æ–≤
                // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ —Å–æ—Å–µ–¥–Ω–∏–µ –∫–ª–µ—Ç–∫–∏
                let startR = Math.floor((b.y - RADIUS) / DIAMETER) - 1;
                let endR = startR + 3;
                
                for (let r = Math.max(0, startR); r < Math.min(rows, endR); r++) {
                    for (let c = 0; c < cols; c++) {
                        let cell = grid[r][c];
                        if (cell) {
                            let distSq = (b.x - cell.x)**2 + (b.y - cell.y)**2;
                            if (distSq < (DIAMETER * 0.85)**2) { // 0.85 - —á—É—Ç—å –º–µ–Ω—å—à–µ –¥–∏–∞–º–µ—Ç—Ä–∞ –¥–ª—è –º—è–≥–∫–æ–≥–æ –∫–∞—Å–∞–Ω–∏—è
                                snapBall(b);
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            function snapBall(b) {
                // –ù–∞—Ö–æ–¥–∏–º –±–ª–∏–∂–∞–π—à—É—é —Å–≤–æ–±–æ–¥–Ω—É—é —è—á–µ–π–∫—É
                let c = Math.round((b.x - offsetX - RADIUS) / DIAMETER);
                let r = Math.round((b.y - RADIUS) / DIAMETER);
                
                // –ö–æ—Ä—Ä–µ–∫—Ü–∏—è –≥—Ä–∞–Ω–∏—Ü
                c = Math.max(0, Math.min(c, cols - 1));
                r = Math.max(0, Math.min(r, rows - 1));

                // –ï—Å–ª–∏ –∑–∞–Ω—è—Ç–æ, –∏—â–µ–º —Å–æ—Å–µ–¥–∞ (–æ—á–µ–Ω—å –ø—Ä–æ—Å—Ç–æ–π –∞–ª–≥–æ—Ä–∏—Ç–º, –º–æ–∂–Ω–æ —É–ª—É—á—à–∏—Ç—å)
                if (grid[r] && grid[r][c]) {
                     r++; // –ü—Ä–æ—Å—Ç–æ —Å—Ç–∞–≤–∏–º –Ω–∏–∂–µ, –µ—Å–ª–∏ –ø–æ–ø–∞–ª–∏ –ø—Ä—è–º–æ –≤ –±–ª–∏–Ω
                }
                
                if (r >= rows) return endGame(); // –°–ª–∏—à–∫–æ–º –Ω–∏–∑–∫–æ

                // –î–æ–±–∞–≤–ª—è–µ–º
                if (!grid[r]) grid[r] = new Array(cols).fill(null);
                addBall(r, c, b.type);
                
                // –õ–æ–≥–∏–∫–∞ –≤–∑—Ä—ã–≤–æ–≤ –∏ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
                let hitBomb = false;
                let neighbors = getNeighbors(r, c);
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –≤–∑—Ä—ã–≤ –±–æ–º–±—ã —Ä—è–¥–æ–º
                neighbors.forEach(n => {
                    if (grid[n.r][n.c].type === BOMB_TYPE) { explode(n.r, n.c); hitBomb = true; }
                });

                if (!hitBomb) {
                    if (b.type === BOMB_TYPE) {
                        explode(r, c);
                    } else {
                        let matches = findMatches(r, c, b.type, []);
                        if (matches.length >= 3) {
                            sounds.pop();
                            removeBalls(matches);
                            score += matches.length * 10;
                            checkFloating();
                        } else {
                            sounds.miss();
                            lives--;
                            if (lives <= 0) {
                                addRow();
                                lives = MAX_LIVES;
                            }
                        }
                    }
                }
                
                resetShot();
                updateUI();
                checkLose();
            }

            function findMatches(r, c, type, visited) {
                let key = r + ',' + c;
                if (visited.includes(key)) return [];
                visited.push(key);
                
                let matches = [{r,c}];
                let neighbors = getNeighbors(r, c);
                
                neighbors.forEach(n => {
                    if (grid[n.r][n.c].type === type) {
                        matches = matches.concat(findMatches(n.r, n.c, type, visited));
                    }
                });
                return matches;
            }

            function getNeighbors(r, c) {
                let dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                let res = [];
                dirs.forEach(d => {
                    let nr = r + d[0], nc = c + d[1];
                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr] && grid[nr][nc]) {
                        res.push({r: nr, c: nc});
                    }
                });
                return res;
            }

            function removeBalls(list) {
                list.forEach(p => {
                    if (grid[p.r][p.c]) {
                        createParticles(grid[p.r][p.c].x, grid[p.r][p.c].y, grid[p.r][p.c].type);
                        grid[p.r][p.c] = null;
                    }
                });
            }

            function explode(r, c) {
                sounds.bomb();
                let range = 2; // –†–∞–¥–∏—É—Å –≤–∑—Ä—ã–≤–∞
                for (let i = r - range; i <= r + range; i++) {
                    for (let j = c - range; j <= c + range; j++) {
                        if (i >= 0 && i < rows && j >= 0 && j < cols && grid[i] && grid[i][j]) {
                             createParticles(grid[i][j].x, grid[i][j].y, BOMB_TYPE);
                             grid[i][j] = null;
                             score += 5;
                        }
                    }
                }
                checkFloating();
            }

            function checkFloating() {
                // BFS –æ—Ç –ø–æ—Ç–æ–ª–∫–∞. –í—Å–µ, —á—Ç–æ –Ω–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–æ —Å r=0, –ø–∞–¥–∞–µ—Ç.
                let connected = new Set();
                let queue = [];
                
                // –î–æ–±–∞–≤–ª—è–µ–º –ø–µ—Ä–≤—ã–π —Ä—è–¥
                if (grid[0]) {
                    for (let c = 0; c < cols; c++) {
                        if (grid[0][c]) {
                            let key = '0,' + c;
                            connected.add(key);
                            queue.push({r:0, c:c});
                        }
                    }
                }

                while(queue.length > 0) {
                    let curr = queue.shift();
                    let ns = getNeighbors(curr.r, curr.c);
                    ns.forEach(n => {
                        let key = n.r + ',' + n.c;
                        if (!connected.has(key)) {
                            connected.add(key);
                            queue.push(n);
                        }
                    });
                }

                // –í—Å–µ —á—Ç–æ –Ω–µ –≤ connected - –ø–∞–¥–∞–µ—Ç
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (grid[r][c] && !connected.has(r + ',' + c)) {
                            let cell = grid[r][c];
                            falling.push({
                                x: cell.x, y: cell.y, type: cell.type,
                                vx: (Math.random()-0.5)*10, vy: -5, rot: 0, rotSpd: (Math.random()-0.5)*0.2
                            });
                            grid[r][c] = null;
                            score += 20;
                        }
                    }
                }
            }

            function addRow() {
                // –°–¥–≤–∏–≥–∞–µ–º –≤–Ω–∏–∑
                for (let r = rows - 2; r >= 0; r--) {
                    grid[r+1] = grid[r];
                    // –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã Y
                    if (grid[r+1]) {
                        for(let c=0; c<cols; c++) {
                            if(grid[r+1][c]) grid[r+1][c].y += DIAMETER;
                        }
                    }
                }
                // –ù–æ–≤—ã–π —Ä—è–¥ —Å–≤–µ—Ä—Ö—É
                grid[0] = new Array(cols).fill(null);
                for (let c = 0; c < cols; c++) {
                    if(Math.random() > 0.2) addBall(0, c, Math.random()<0.05?BOMB_TYPE:randType());
                }
            }

            function createParticles(x, y, type) {
                let color = type === BOMB_TYPE ? '#333' : PANCAKE_TYPES[type].color;
                for(let i=0; i<8; i++) {
                    particles.push({
                        x: x, y: y,
                        vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
                        life: 1, color: color
                    });
                }
            }

            function resetShot() {
                shooter.ball = null;
                shooter.curr = shooter.next;
                shooter.next = randType();
            }

            function checkLose() {
                // –ï—Å–ª–∏ –±–ª–∏–Ω—ã —Å–ª–∏—à–∫–æ–º –Ω–∏–∑–∫–æ
                for(let c=0; c<cols; c++) {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä—è–¥ –±–ª–∏–∑–∫–æ –∫ —Å—Ç—Ä–µ–ª–∫—É
                    let dangerRow = Math.floor((shooter.y - RADIUS * 2) / DIAMETER);
                    if (grid[dangerRow] && grid[dangerRow][c]) {
                        endGame();
                        return;
                    }
                }
            }

            function endGame() {
                state = 'END';
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('blini_hs', highScore);
                }
                document.getElementById('modal-title').innerText = "–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê";
                document.getElementById('modal-desc').innerHTML = `–°—á–µ—Ç: ${score}<br>–†–µ–∫–æ—Ä–¥: ${highScore}`;
                document.getElementById('flavors-section').style.display = 'none';
                document.getElementById('action-btn').innerText = "–ü–û–ü–†–û–ë–û–í–ê–¢–¨ –°–ù–û–í–ê";
                toggleModal('modal', true);
            }

            // === –û–¢–†–ò–°–û–í–ö–ê ===
            function draw() {
                // –û—á–∏—Å—Ç–∫–∞ —Å —É—á–µ—Ç–æ–º dvh (—Ñ–æ–Ω CSS, —Ç—É—Ç —á–∏—Å—Ç–∏–º canvas)
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // –†–∏—Å—É–µ–º —Å–µ—Ç–∫—É
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (grid[r] && grid[r][c]) drawPancake(grid[r][c].x, grid[r][c].y, grid[r][c].type);
                    }
                }

                // –†–∏—Å—É–µ–º –ø–∞–¥–∞—é—â–∏–µ
                falling.forEach(f => {
                    ctx.save();
                    ctx.translate(f.x, f.y);
                    ctx.rotate(f.rot);
                    drawPancake(0, 0, f.type);
                    ctx.restore();
                });

                // –†–∏—Å—É–µ–º —á–∞—Å—Ç–∏—Ü—ã
                particles.forEach(p => {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, RADIUS/3, 0, Math.PI*2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                });

                // –°—Ç—Ä–µ–ª–æ–∫
                if (state !== 'MENU') {
                    // –õ–∏–Ω–∏—è –ø—Ä–∏—Ü–µ–ª–∞
                    if (isAiming && !shooter.ball) {
                        ctx.beginPath();
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.lineWidth = 4;
                        ctx.setLineDash([10, 10]);
                        ctx.moveTo(shooter.x, shooter.y);
                        ctx.lineTo(shooter.x + Math.cos(aimAngle)*canvas.height, shooter.y + Math.sin(aimAngle)*canvas.height);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }

                    // –¢–µ–∫—É—â–∏–π –±–ª–∏–Ω
                    if (!shooter.ball) {
                         drawPancake(shooter.x, shooter.y, shooter.curr);
                    } else {
                         drawPancake(shooter.ball.x, shooter.ball.y, shooter.ball.type);
                    }
                    
                    // –°–ª–µ–¥—É—é—â–∏–π –±–ª–∏–Ω (–º–∞–ª–µ–Ω—å–∫–∏–π —Å–±–æ–∫—É)
                    ctx.save();
                    ctx.translate(shooter.x + RADIUS * 2.5, shooter.y + RADIUS);
                    ctx.scale(0.6, 0.6);
                    drawPancake(0, 0, shooter.next);
                    ctx.restore();
                }
            }

            function drawPancake(x, y, type) {
                let r = RADIUS - 1; // –ß—É—Ç—å –º–µ–Ω—å—à–µ –¥–ª—è –∑–∞–∑–æ—Ä–∞
                
                if (type === BOMB_TYPE) {
                    // –ë–æ–º–±–∞
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI*2);
                    ctx.fillStyle = '#333';
                    ctx.fill();
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#fff';
                    ctx.stroke();
                    // –§–∏—Ç–∏–ª—å
                    ctx.fillStyle = 'red';
                    ctx.font = `${r}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üí£', x, y+2);
                    return;
                }

                let img = pancakeImgs[type];
                if (img && img.complete && img.naturalWidth > 0) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI*2);
                    ctx.clip();
                    // –†–∏—Å—É–µ–º —Ñ–æ–Ω
                    ctx.fillStyle = PANCAKE_TYPES[type].color;
                    ctx.fill();
                    // –†–∏—Å—É–µ–º –∫–∞—Ä—Ç–∏–Ω–∫—É
                    ctx.drawImage(img, x-r, y-r, r*2, r*2);
                    // –û–±–≤–æ–¥–∫–∞
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = PANCAKE_TYPES[type].border;
                    ctx.stroke();
                    ctx.restore();
                } else {
                    // –§–æ–ª–±—ç–∫ (–ø—Ä–æ—Å—Ç–æ –∫—Ä—É–≥–∏)
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI*2);
                    ctx.fillStyle = PANCAKE_TYPES[type].color;
                    ctx.fill();
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = PANCAKE_TYPES[type].border;
                    ctx.stroke();
                }
                
                // –ë–ª–∏–∫
                ctx.beginPath();
                ctx.arc(x - r*0.3, y - r*0.3, r*0.2, 0, Math.PI*2);
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.fill();
            }

            function loop() {
                update();
                draw();
                requestAnimationFrame(loop);
            }

            // === –í–í–û–î (TOUCH + MOUSE) ===
            function handleStart(x, y) {
                if (state !== 'PLAYING' || shooter.ball) return;
                isAiming = true;
                handleMove(x, y);
            }
            
            function handleMove(x, y) {
                if (!isAiming) return;
                let dx = x - shooter.x;
                let dy = y - shooter.y;
                if (dy > -20) dy = -20; // –ù–µ —Å—Ç—Ä–µ–ª—è—Ç—å –≤–Ω–∏–∑
                aimAngle = Math.atan2(dy, dx);
            }
            
            function handleEnd() {
                if (isAiming) {
                    isAiming = false;
                    fire();
                }
            }
            
            function fire() {
                sounds.shoot();
                shooter.ball = {
                    x: shooter.x, y: shooter.y, type: shooter.curr,
                    vx: Math.cos(aimAngle) * SPEED,
                    vy: Math.sin(aimAngle) * SPEED
                };
            }
            
            function getPos(e) {
                let rect = canvas.getBoundingClientRect();
                let clientX = e.touches ? e.touches[0].clientX : e.clientX;
                let clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return { x: clientX - rect.left, y: clientY - rect.top };
            }

            // –°–ª—É—à–∞—Ç–µ–ª–∏ —Å–æ–±—ã—Ç–∏–π
            // preventDefault –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –æ—Ç–∫–ª—é—á–µ–Ω–∏—è —Å–∫—Ä–æ–ª–ª–∞ –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö
            canvas.addEventListener('mousedown', e => handleStart(getPos(e).x, getPos(e).y));
            canvas.addEventListener('mousemove', e => handleMove(getPos(e).x, getPos(e).y));
            window.addEventListener('mouseup', handleEnd);

            canvas.addEventListener('touchstart', e => {
                e.preventDefault();
                let pos = getPos(e);
                handleStart(pos.x, pos.y);
            }, {passive: false});
            
            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                let pos = getPos(e);
                handleMove(pos.x, pos.y);
            }, {passive: false});
            
            window.addEventListener('touchend', handleEnd);

            // UI –ª–æ–≥–∏–∫–∞
            document.getElementById('action-btn').onclick = initGame;
            document.getElementById('pauseBtn').onclick = () => {
                if (state === 'PLAYING') {
                    state = 'PAUSED';
                    document.getElementById('pauseScore').innerText = score;
                    document.getElementById('pauseLives').innerText = lives;
                    toggleModal('pauseModal', true);
                }
            };
            document.getElementById('resumeBtn').onclick = () => {
                state = 'PLAYING';
                toggleModal('pauseModal', false);
            };
            document.getElementById('soundToggle').onclick = function() {
                soundEnabled = !soundEnabled;
                this.classList.toggle('muted');
                if(soundEnabled) audioCtx.resume();
            };

            function toggleModal(id, show) {
                const el = document.getElementById(id);
                if (show) el.classList.remove('hidden'); else el.classList.add('hidden');
            }

            function updateUI() {
                document.getElementById('score').innerText = score;
                document.getElementById('high-score').innerText = highScore;
                const lc = document.getElementById('lives-container');
                lc.innerHTML = '';
                for(let i=0; i<MAX_LIVES; i++) {
                    let d = document.createElement('div');
                    d.className = 'life-dot' + (i >= lives ? ' lost' : '');
                    lc.appendChild(d);
                }
            }
            
            window.addEventListener('resize', () => {
                if(state !== 'MENU') resize();
            });

            // –°—Ç–∞—Ä—Ç
            resize();
            loop();

        })();
    </script>
</body>
</html>
