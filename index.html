<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>‚òÄÔ∏è –ë–õ–ò–ù–ù–´–ô –®–£–¢–ï–†: –§–∏–Ω–∞–ª</title>
    <style>
        /* ===== –°–¢–ò–õ–ò ===== */
        * {
            margin: 0; padding: 0; box-sizing: border-box;
            touch-action: none; user-select: none; -webkit-tap-highlight-color: transparent;
            font-family: 'Segoe UI', sans-serif;
        }
        body {
            height: 100vh; height: 100dvh; width: 100vw; overflow: hidden;
            background: radial-gradient(circle at 20% 30%, #fbe9d2, #fad0a5);
            display: flex; justify-content: center; align-items: center;
        }
        .sky-background {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;
            background: linear-gradient(145deg, #ffdab9 0%, #ffe5b4 40%, #ffd6a5 100%);
        }
        .sun-rays {
            position: absolute; top: -10vw; left: -10vw; width: 60vw; height: 60vw;
            background: radial-gradient(circle, #ffdd77 0%, rgba(255, 221, 119, 0) 70%);
            border-radius: 50%; opacity: 0.5; animation: spin 40s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        .game-wrapper {
            position: relative; width: 100%; height: 100%; max-width: 500px;
            display: flex; flex-direction: column;
            background: linear-gradient(rgba(255, 222, 191, 0.9), rgba(255, 228, 204, 0.9)), url('—Ñ–æ–Ω_2.jpeg') center/cover;
            box-shadow: 0 0 20px rgba(0,0,0,0.2); overflow: hidden;
        }
        @media (min-width: 501px) { .game-wrapper { height: 95dvh; border-radius: 30px; border: 6px solid #d2691e; } }

        .header {
            flex: 0 0 auto; height: 80px; background: linear-gradient(165deg, #ffecd2, #fcdec2);
            border-bottom: 5px solid #c28a3b; display: flex; justify-content: space-around; align-items: center;
            z-index: 20; border-radius: 0 0 25px 25px; box-shadow: 0 5px 10px rgba(0,0,0,0.1);
        }
        .stat-item { display: flex; flex-direction: column; align-items: center; }
        .stat-label { font-size: 10px; color: #7b3f00; font-weight: 800; text-transform: uppercase; }
        .stat-value { font-size: 22px; font-weight: 900; color: #a0522d; }
        .lives-row { display: flex; gap: 4px; margin-top: 2px; }
        .life-dot { width: 12px; height: 12px; background: #d41a1a; border-radius: 50%; border: 1px solid #9c5a2c; }
        .life-dot.lost { background: #ccc; opacity: 0.5; }

        .canvas-container { flex: 1; position: relative; width: 100%; overflow: hidden; box-shadow: inset 0 0 20px rgba(139, 69, 19, 0.2); cursor: crosshair; }
        canvas { display: block; width: 100%; height: 100%; }

        /* –ú–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞ */
        .modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(60, 30, 10, 0.8); backdrop-filter: blur(4px);
            display: flex; align-items: center; justify-content: center; z-index: 100;
        }
        .hidden { display: none !important; }
        .modal-content {
            background: #fff8e1; padding: 25px; border-radius: 20px; width: 85%; max-width: 320px;
            text-align: center; border: 4px solid #ffa000; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .big-btn {
            background: linear-gradient(#ff9800, #f57c00); border: none; color: white;
            padding: 12px 30px; font-size: 18px; font-weight: bold; border-radius: 50px;
            box-shadow: 0 4px 0 #e65100; width: 100%; margin-top: 15px;
        }
        .big-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 #e65100; }

        .game-controls {
            position: absolute; bottom: 20px; width: 100%; display: flex; justify-content: space-between; padding: 0 20px; pointer-events: none;
        }
        .control-btn {
            width: 50px; height: 50px; background: #ffb74d; border: 2px solid #ffe082;
            border-radius: 50%; display: flex; justify-content: center; align-items: center;
            font-size: 24px; color: white; box-shadow: 0 4px 0 #e65100; pointer-events: auto; cursor: pointer;
        }
        .control-btn:active { transform: translateY(4px); box-shadow: none; }
        .muted { filter: grayscale(1); opacity: 0.7; }
        
        /* –ò–∫–æ–Ω–∫–∏ –Ω–∞—á–∏–Ω–æ–∫ */
        .flavors-grid { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin: 10px 0; }
        .flavor-icon { width: 40px; height: 40px; background-size: cover; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
    </style>
</head>
<body>
    <div class="sky-background"><div class="sun-rays"></div></div>

    <div class="game-wrapper">
        <div class="header">
            <div class="stat-item"><span class="stat-label">–°—á–µ—Ç</span><span class="stat-value" id="score">0</span></div>
            <div class="stat-item"><span class="stat-label">–ñ–∏–∑–Ω–∏</span><div class="lives-row" id="lives-container"></div></div>
            <div class="stat-item"><span class="stat-label">–†–µ–∫–æ—Ä–¥</span><span class="stat-value" id="high-score">0</span></div>
        </div>

        <div class="canvas-container" id="canvas-container">
            <canvas id="gameCanvas"></canvas>
            
            <div id="modal" class="modal">
                <div class="modal-content">
                    <h1 style="color:#d84315; margin-bottom:10px;">‚òÄÔ∏è –ú–ê–°–õ–ï–ù–ò–¶–ê</h1>
                    <p style="color:#5d4037; font-size:14px;">–°–æ–±–∏—Ä–∞–π –±–ª–∏–Ω—ã 3 –≤ —Ä—è–¥!</p>
                    <div id="flavors-section" class="flavors-grid">
                        <div class="flavor-icon" style="background-image: url('honey.png'); background-color: #ffd54f"></div>
                        <div class="flavor-icon" style="background-image: url('Strawberry.png'); background-color: #ef5350"></div>
                        <div class="flavor-icon" style="background-image: url('milk.png'); background-color: #fff176"></div>
                        <div class="flavor-icon" style="background-image: url('cheese.png'); background-color: #ffca28"></div>
                        <div class="flavor-icon" style="background-image: url('meat.png'); background-color: #8d6e63"></div>
                        <div class="flavor-icon" style="background: #333; display:flex; align-items:center; justify-content:center; color:white;">üí£</div>
                    </div>
                    <button id="action-btn" class="big-btn">–ò–ì–†–ê–¢–¨</button>
                </div>
            </div>

            <div id="pauseModal" class="modal hidden">
                <div class="modal-content">
                    <h2>‚è∏ –ü–ê–£–ó–ê</h2>
                    <p>–°—á–µ—Ç: <span id="pauseScore">0</span></p>
                    <button id="resumeBtn" class="big-btn" style="background: linear-gradient(#66bb6a, #43a047); box-shadow: 0 4px 0 #2e7d32;">–ü–†–û–î–û–õ–ñ–ò–¢–¨</button>
                </div>
            </div>
        </div>

        <div class="game-controls">
            <div id="pauseBtn" class="control-btn">II</div>
            <div id="soundToggle" class="control-btn">‚ô´</div>
        </div>
    </div>

    <script>
        (function(){
            // === –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ===
            const canvas = document.getElementById('gameCanvas');
            const container = document.getElementById('canvas-container');
            const ctx = canvas.getContext('2d', { alpha: false });

            // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
            let RADIUS, DIAMETER, SPEED;
            const COLUMNS_MOBILE = 9;  
            const MAX_LIVES = 5;

            // –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
            const PANCAKE_IMAGES = ['honey.png', 'Strawberry.png', 'milk.png', 'cheese.png', 'meat.png'];
            const BOMB_IMAGE = 'bomb.png';
            
            const PANCAKE_TYPES = [
                { color: '#FFC107', border: '#FF6F00' },
                { color: '#FF5252', border: '#B71C1C' },
                { color: '#FFF59D', border: '#FBC02D' },
                { color: '#FFEB3B', border: '#F57F17' },
                { color: '#A1887F', border: '#5D4037' }
            ];
            const BOMB_TYPE = 99;

            let pancakeImgs = [];
            PANCAKE_IMAGES.forEach(src => { let img = new Image(); img.src = src; pancakeImgs.push(img); });

            // –°–æ—Å—Ç–æ—è–Ω–∏–µ
            let grid = [], particles = [], falling = [];
            let rows = 0, cols = 0, offsetX = 0;
            let score = 0, lives = MAX_LIVES, highScore = localStorage.getItem('blini_hs') || 0;
            let state = 'MENU';
            let shooter = { x: 0, y: 0, curr: 0, next: 0, ball: null };
            
            let isAiming = false;
            let aimAngle = -Math.PI / 2;
            let soundEnabled = true;

            // === –ó–í–£–ö ===
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            const audioCtx = new AudioContext();

            function tryResumeAudio() {
                if (audioCtx.state === 'suspended') audioCtx.resume();
            }
            
            function playTone(freq, type, duration) {
                if (!soundEnabled) return;
                try {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gain.gain.exponentialRampToValue(0.01, audioCtx.currentTime + duration);
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.start();
                    osc.stop(audioCtx.currentTime + duration);
                } catch(e) {}
            }

            const sounds = {
                shoot: () => playTone(600, 'sine', 0.15),
                pop: () => playTone(400, 'sine', 0.1),
                bomb: () => playTone(100, 'sawtooth', 0.3),
                miss: () => playTone(150, 'triangle', 0.3)
            };

            // === –ê–î–ê–ü–¢–ò–í–ù–û–°–¢–¨ ===
            function resize() {
                const rect = container.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;

                cols = COLUMNS_MOBILE; 
                DIAMETER = Math.floor(canvas.width / cols);
                RADIUS = DIAMETER / 2;
                offsetX = (canvas.width - cols * DIAMETER) / 2;
                rows = Math.floor(canvas.height / DIAMETER) + 1;
                SPEED = canvas.height * 0.035; 

                shooter.x = canvas.width / 2;
                shooter.y = canvas.height - RADIUS * 2.5;
            }

            // === –ò–ì–†–û–í–û–ô –¶–ò–ö–õ ===
            function initGame() {
                tryResumeAudio();
                resize();
                score = 0; lives = MAX_LIVES; state = 'PLAYING';
                grid = []; particles = []; falling = [];
                for (let r = 0; r < rows; r++) grid[r] = new Array(cols).fill(null);
                for (let r = 0; r < 5; r++) createRow(r);

                shooter.curr = randType();
                shooter.next = randType();
                shooter.ball = null;
                
                updateUI();
                toggleModal('modal', false);
                toggleModal('pauseModal', false);
            }

            function createRow(r) {
                for (let c = 0; c < cols; c++) {
                    if (Math.random() > 0.3) addBall(r, c, Math.random() < 0.05 ? BOMB_TYPE : randType());
                }
            }

            function addBall(r, c, type) {
                if (!grid[r]) return;
                grid[r][c] = { type: type, x: offsetX + c * DIAMETER + RADIUS, y: r * DIAMETER + RADIUS };
            }

            function randType() { return Math.floor(Math.random() * PANCAKE_IMAGES.length); }

            function update() {
                if (state !== 'PLAYING') return;

                // –î–≤–∏–∂–µ–Ω–∏–µ —à–∞—Ä–∞
                if (shooter.ball) {
                    let b = shooter.ball;
                    const steps = 6;
                    for (let i = 0; i < steps; i++) {
                        b.x += b.vx / steps;
                        b.y += b.vy / steps;

                        // –°—Ç–µ–Ω—ã
                        if (b.x < RADIUS) { b.x = RADIUS; b.vx *= -1; }
                        if (b.x > canvas.width - RADIUS) { b.x = canvas.width - RADIUS; b.vx *= -1; }
                        
                        // –ü–æ—Ç–æ–ª–æ–∫
                        if (b.y < RADIUS) { b.y = RADIUS; snapBall(b, -1, -1); return; } // -1 –∑–Ω–∞—á–∏—Ç "–ø–æ—Ç–æ–ª–æ–∫"
                        
                        // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ
                        let hit = checkCollision(b);
                        if (hit) {
                            snapBall(b, hit.r, hit.c); // –ü–µ—Ä–µ–¥–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ç–æ–≥–æ, –≤ –∫–æ–≥–æ –≤—Ä–µ–∑–∞–ª–∏—Å—å
                            return;
                        }
                    }
                    if (b.y > canvas.height + RADIUS) resetShot();
                }

                // –≠—Ñ—Ñ–µ–∫—Ç—ã
                for (let i = particles.length - 1; i >= 0; i--) {
                    let p = particles[i];
                    p.x += p.vx; p.y += p.vy; p.life -= 0.03; p.vy += 0.5;
                    if (p.life <= 0) particles.splice(i, 1);
                }
                for (let i = falling.length - 1; i >= 0; i--) {
                    let f = falling[i];
                    f.x += f.vx; f.y += f.vy; f.vy += 0.8; f.rot += f.rotSpd;
                    if (f.y > canvas.height + DIAMETER) falling.splice(i, 1);
                }
            }

            // === –£–õ–£–ß–®–ï–ù–ù–ê–Ø –§–ò–ó–ò–ö–ê ===
            function checkCollision(b) {
                let startR = Math.floor((b.y - RADIUS) / DIAMETER) - 1;
                let endR = startR + 3;
                
                for (let r = Math.max(0, startR); r < Math.min(rows, endR); r++) {
                    for (let c = 0; c < cols; c++) {
                        let cell = grid[r]?.[c];
                        if (cell) {
                            let distSq = (b.x - cell.x)**2 + (b.y - cell.y)**2;
                            // 0.85 –¥–∏–∞–º–µ—Ç—Ä–∞ - –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ –¥–ª—è "–ø—Ä–æ—Ç–∏—Å–∫–∏–≤–∞–Ω–∏—è"
                            if (distSq < (DIAMETER * 0.85)**2) {
                                return { r: r, c: c }; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º, –≤ –∫–æ–≥–æ –ø–æ–ø–∞–ª–∏
                            }
                        }
                    }
                }
                return null;
            }

            // –£–ú–ù–ê–Ø –ü–ê–†–ö–û–í–ö–ê –®–ê–†–ê
            function snapBall(b, hitR, hitC) {
                let bestR = -1, bestC = -1;
                let minDist = Infinity;

                // –ï—Å–ª–∏ —É–¥–∞—Ä–∏–ª–∏—Å—å –≤ —à–∞—Ä, –∏—â–µ–º —Å–≤–æ–±–æ–¥–Ω–æ–µ –º–µ—Å—Ç–æ –¢–û–õ–¨–ö–û –≤–æ–∫—Ä—É–≥ –Ω–µ–≥–æ
                if (hitR !== -1) {
                    let neighbors = [
                        {r: hitR, c: hitC - 1}, {r: hitR, c: hitC + 1}, 
                        {r: hitR + 1, c: hitC}, {r: hitR - 1, c: hitC}
                    ];
                    // –î–æ–±–∞–≤–ª—è–µ–º –¥–∏–∞–≥–æ–Ω–∞–ª–∏ –¥–ª—è —É–≥–ª–æ–≤—ã—Ö —É–¥–∞—Ä–æ–≤
                    neighbors.push({r:hitR+1, c:hitC-1}, {r:hitR+1, c:hitC+1}, {r:hitR-1, c:hitC-1}, {r:hitR-1, c:hitC+1});

                    neighbors.forEach(n => {
                        if (n.r >= 0 && n.r < rows && n.c >= 0 && n.c < cols && (!grid[n.r] || !grid[n.r][n.c])) {
                            let cellX = offsetX + n.c * DIAMETER + RADIUS;
                            let cellY = n.r * DIAMETER + RADIUS;
                            let dist = (b.x - cellX)**2 + (b.y - cellY)**2;
                            if (dist < minDist) { minDist = dist; bestR = n.r; bestC = n.c; }
                        }
                    });
                } 
                
                // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –º–µ—Å—Ç–æ (–∏–ª–∏ —É–¥–∞—Ä –≤ –ø–æ—Ç–æ–ª–æ–∫), –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—ã—á–Ω–æ–µ –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ
                if (bestR === -1) {
                    bestC = Math.round((b.x - offsetX - RADIUS) / DIAMETER);
                    bestR = Math.round((b.y - RADIUS) / DIAMETER);
                }

                // –ó–∞—â–∏—Ç–∞ –≥—Ä–∞–Ω–∏—Ü
                bestC = Math.max(0, Math.min(bestC, cols - 1));
                bestR = Math.max(0, Math.min(bestR, rows - 1));
                
                // –ï—Å–ª–∏ –º–µ—Å—Ç–æ –≤—Å—ë —Ä–∞–≤–Ω–æ –∑–∞–Ω—è—Ç–æ (—Ä–µ–¥–∫–∏–π —Å–ª—É—á–∞–π), —Å–¥–≤–∏–≥–∞–µ–º –≤–Ω–∏–∑
                if (grid[bestR] && grid[bestR][bestC]) bestR++; 
                if (bestR >= rows) return endGame();

                // –°—Ç–∞–≤–∏–º —à–∞—Ä
                if (!grid[bestR]) grid[bestR] = new Array(cols).fill(null);
                addBall(bestR, bestC, b.type);
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∑—Ä—ã–≤–æ–≤ –∏ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
                let hitBomb = false;
                getNeighbors(bestR, bestC).forEach(n => {
                    if (grid[n.r][n.c].type === BOMB_TYPE) { explode(n.r, n.c); hitBomb = true; }
                });

                if (!hitBomb) {
                    if (b.type === BOMB_TYPE) explode(bestR, bestC);
                    else {
                        let matches = findMatches(bestR, bestC, b.type, []);
                        if (matches.length >= 3) {
                            sounds.pop(); removeBalls(matches); score += matches.length * 10; checkFloating();
                        } else {
                            sounds.miss(); lives--;
                            if (lives <= 0) { addRow(); lives = MAX_LIVES; }
                        }
                    }
                }
                resetShot(); updateUI(); checkLose();
            }

            function findMatches(r, c, type, visited) {
                let key = r + ',' + c;
                if (visited.includes(key)) return [];
                visited.push(key);
                let matches = [{r,c}];
                getNeighbors(r, c).forEach(n => {
                    if (grid[n.r][n.c].type === type) matches = matches.concat(findMatches(n.r, n.c, type, visited));
                });
                return matches;
            }

            function getNeighbors(r, c) {
                return [[0,1], [0,-1], [1,0], [-1,0]]
                    .map(d => ({r: r + d[0], c: c + d[1]}))
                    .filter(n => n.r >= 0 && n.r < rows && n.c >= 0 && n.c < cols && grid[n.r] && grid[n.r][n.c]);
            }

            function removeBalls(list) {
                list.forEach(p => {
                    if (grid[p.r][p.c]) {
                        createParticles(grid[p.r][p.c].x, grid[p.r][p.c].y, grid[p.r][p.c].type);
                        grid[p.r][p.c] = null;
                    }
                });
            }

            function explode(r, c) {
                sounds.bomb();
                let range = 2;
                for (let i = r - range; i <= r + range; i++) {
                    for (let j = c - range; j <= c + range; j++) {
                        if (i >= 0 && i < rows && j >= 0 && j < cols && grid[i] && grid[i][j]) {
                            createParticles(grid[i][j].x, grid[i][j].y, BOMB_TYPE);
                            grid[i][j] = null;
                            score += 5;
                        }
                    }
                }
                checkFloating();
            }

            function checkFloating() {
                // BFS –æ—Ç –ø–æ—Ç–æ–ª–∫–∞
                let connected = new Set();
                let queue = [];
                if (grid[0]) {
                    for (let c = 0; c < cols; c++) if (grid[0][c]) { connected.add('0,' + c); queue.push({r:0, c:c}); }
                }
                while(queue.length > 0) {
                    let curr = queue.shift();
                    getNeighbors(curr.r, curr.c).forEach(n => {
                        let key = n.r + ',' + n.c;
                        if (!connected.has(key)) { connected.add(key); queue.push(n); }
                    });
                }
                // –£–¥–∞–ª—è–µ–º –≤—Å—ë, —á—Ç–æ –Ω–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–æ
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (grid[r][c] && !connected.has(r + ',' + c)) {
                            let cell = grid[r][c];
                            falling.push({ x: cell.x, y: cell.y, type: cell.type, vx: (Math.random()-0.5)*10, vy: -5, rot: 0, rotSpd: (Math.random()-0.5)*0.2 });
                            grid[r][c] = null; score += 20;
                        }
                    }
                }
            }

            function addRow() {
                for (let r = rows - 2; r >= 0; r--) {
                    grid[r+1] = grid[r];
                    if (grid[r+1]) for(let c=0; c<cols; c++) if(grid[r+1][c]) grid[r+1][c].y += DIAMETER;
                }
                grid[0] = new Array(cols).fill(null);
                for (let c = 0; c < cols; c++) if(Math.random() > 0.2) addBall(0, c, Math.random()<0.05?BOMB_TYPE:randType());
            }

            function createParticles(x, y, type) {
                let color = type === BOMB_TYPE ? '#333' : PANCAKE_TYPES[type].color;
                for(let i=0; i<8; i++) particles.push({ x: x, y: y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 1, color: color });
            }

            function resetShot() {
                shooter.ball = null; shooter.curr = shooter.next; shooter.next = randType();
            }

            function checkLose() {
                for(let c=0; c<cols; c++) {
                    let dangerRow = Math.floor((shooter.y - RADIUS * 2) / DIAMETER);
                    if (grid[dangerRow] && grid[dangerRow][c]) { endGame(); return; }
                }
            }

            function endGame() {
                state = 'END';
                if (score > highScore) { highScore = score; localStorage.setItem('blini_hs', highScore); }
                document.getElementById('pauseScore').innerText = score; 
                document.getElementById('flavors-section').style.display = 'none';
                document.getElementById('action-btn').innerText = "–ï–©–ï –†–ê–ó";
                toggleModal('modal', true);
            }

            // === –û–¢–†–ò–°–û–í–ö–ê ===
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) if (grid[r]?.[c]) drawPancake(grid[r][c].x, grid[r][c].y, grid[r][c].type);
                falling.forEach(f => { ctx.save(); ctx.translate(f.x, f.y); ctx.rotate(f.rot); drawPancake(0, 0, f.type); ctx.restore(); });
                particles.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, RADIUS/3, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; });

                if (state !== 'MENU') {
                    // –¢–†–ê–ï–ö–¢–û–†–ò–Ø
                    if (isAiming && !shooter.ball) {
                        ctx.beginPath();
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                        ctx.lineWidth = 4;
                        ctx.setLineDash([10, 15]);

                        let simX = shooter.x, simY = shooter.y;
                        let simVx = Math.cos(aimAngle) * 15, simVy = Math.sin(aimAngle) * 15;
                        ctx.moveTo(simX, simY);

                        for(let i=0; i<40; i++) {
                            simX += simVx; simY += simVy;
                            if (simX < RADIUS || simX > canvas.width - RADIUS) { simVx = -simVx; simX += simVx; }
                            
                            let r = Math.floor((simY - RADIUS) / DIAMETER);
                            let c = Math.round((simX - offsetX - RADIUS) / DIAMETER);
                            if ((r >= 0 && r < rows && c >= 0 && c < cols && grid[r]?.[c]) || simY < RADIUS) break;
                            
                            ctx.lineTo(simX, simY);
                        }
                        ctx.stroke(); ctx.setLineDash([]);
                    }
                    
                    if (!shooter.ball) drawPancake(shooter.x, shooter.y, shooter.curr);
                    else drawPancake(shooter.ball.x, shooter.ball.y, shooter.ball.type);
                    
                    ctx.save(); ctx.translate(shooter.x + RADIUS * 2.5, shooter.y + RADIUS); ctx.scale(0.6, 0.6);
                    drawPancake(0, 0, shooter.next); ctx.restore();
                }
            }

            function drawPancake(x, y, type) {
                let r = RADIUS - 1;
                if (type === BOMB_TYPE) {
                    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fillStyle = '#333'; ctx.fill();
                    ctx.lineWidth = 2; ctx.strokeStyle = '#fff'; ctx.stroke();
                    ctx.fillStyle = 'red'; ctx.font = `${r}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('üí£', x, y+2); return;
                }
                let img = pancakeImgs[type];
                if (img && img.complete && img.naturalWidth > 0) {
                    ctx.save(); ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.clip();
                    ctx.fillStyle = PANCAKE_TYPES[type].color; ctx.fill();
                    ctx.drawImage(img, x-r, y-r, r*2, r*2);
                    ctx.lineWidth = 3; ctx.strokeStyle = PANCAKE_TYPES[type].border; ctx.stroke(); ctx.restore();
                } else {
                    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fillStyle = PANCAKE_TYPES[type].color; ctx.fill();
                    ctx.lineWidth = 3; ctx.strokeStyle = PANCAKE_TYPES[type].border; ctx.stroke();
                }
                ctx.beginPath(); ctx.arc(x - r*0.3, y - r*0.3, r*0.2, 0, Math.PI*2); ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.fill();
            }

            function loop() { update(); draw(); requestAnimationFrame(loop); }

            // === –£–ü–†–ê–í–õ–ï–ù–ò–ï ===
            function getTouchPos(e) {
                const rect = canvas.getBoundingClientRect();
                if (e.touches && e.touches.length > 0) return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
                return { x: e.clientX - rect.left, y: e.clientY - rect.top };
            }

            function inputStart(pos) {
                tryResumeAudio();
                if (state !== 'PLAYING' || shooter.ball) return;
                isAiming = true;
                inputMove(pos);
            }

            function inputMove(pos) {
                if (!isAiming) return;
                let dx = pos.x - shooter.x;
                let dy = pos.y - shooter.y;
                if (dy > -20) dy = -20;
                aimAngle = Math.atan2(dy, dx);
            }

            function inputEnd() {
                if (isAiming) { isAiming = false; fire(); }
            }

            function fire() {
                sounds.shoot();
                shooter.ball = { x: shooter.x, y: shooter.y, type: shooter.curr, vx: Math.cos(aimAngle) * SPEED, vy: Math.sin(aimAngle) * SPEED };
            }

            canvas.addEventListener('touchstart', e => { e.preventDefault(); inputStart(getTouchPos(e)); }, {passive: false});
            canvas.addEventListener('touchmove', e => { e.preventDefault(); inputMove(getTouchPos(e)); }, {passive: false});
            canvas.addEventListener('touchend', e => { e.preventDefault(); inputEnd(); });
            canvas.addEventListener('mousedown', e => { inputStart(getTouchPos(e)); });
            window.addEventListener('mousemove', e => { inputMove(getTouchPos(e)); });
            window.addEventListener('mouseup', inputEnd);

            // UI
            document.getElementById('action-btn').onclick = initGame;
            document.getElementById('pauseBtn').onclick = (e) => {
                e.stopPropagation();
                if (state === 'PLAYING') { state = 'PAUSED'; document.getElementById('pauseScore').innerText = score; toggleModal('pauseModal', true); }
            };
            document.getElementById('resumeBtn').onclick = () => { state = 'PLAYING'; toggleModal('pauseModal', false); };
            document.getElementById('soundToggle').onclick = function(e) {
                e.stopPropagation(); soundEnabled = !soundEnabled; this.classList.toggle('muted'); tryResumeAudio();
            };

            function toggleModal(id, show) {
                const el = document.getElementById(id);
                if (show) el.classList.remove('hidden'); else el.classList.add('hidden');
            }

            function updateUI() {
                document.getElementById('score').innerText = score; document.getElementById('high-score').innerText = highScore;
                const lc = document.getElementById('lives-container'); lc.innerHTML = '';
                for(let i=0; i<MAX_LIVES; i++) { let d = document.createElement('div'); d.className = 'life-dot' + (i >= lives ? ' lost' : ''); lc.appendChild(d); }
            }
            
            window.addEventListener('resize', () => { if(state !== 'MENU') resize(); });

            resize();
            loop();
        })();
    </script>
</body>
</html>
