<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>‚òÄÔ∏è –ë–õ–ò–ù–ù–´–ô –®–£–¢–ï–† ¬∑ –ú–∞—Å–ª–µ–Ω–∏—Ü–∞</title>
    <style>
        /* ===== –ú–û–ë–ò–õ–¨–ù–ê–Ø –ë–ê–ó–ê ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none; /* –û—Ç–∫–ª—é—á–∞–µ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∂–µ—Å—Ç—ã –±—Ä–∞—É–∑–µ—Ä–∞ */
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-family: 'Segoe UI', 'Roboto', 'Helvetica', sans-serif;
        }

        body {
            /* dvh —Ä–µ—à–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—É —Å –ø—Ä—ã–≥–∞—é—â–µ–π –∞–¥—Ä–µ—Å–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π –Ω–∞ iOS/Android */
            height: 100vh;
            height: 100dvh; 
            width: 100vw;
            overflow: hidden;
            background: radial-gradient(circle at 20% 30%, #fbe9d2, #fad0a5);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* –§–æ–Ω —Å –ª—É—á–∞–º–∏ */
        .sky-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: linear-gradient(145deg, #ffdab9 0%, #ffe5b4 40%, #ffd6a5 100%);
            overflow: hidden;
        }

        .sun-rays {
            position: absolute;
            top: -10vw;
            left: -10vw;
            width: 60vw;
            height: 60vw;
            background: radial-gradient(circle, #ffdd77 0%, rgba(255, 221, 119, 0) 70%);
            border-radius: 50%;
            opacity: 0.5;
            animation: spin 40s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* ===== –ò–ì–†–û–í–û–ô –ö–û–ù–¢–ï–ô–ù–ï–† ===== */
        .game-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            /* –ù–∞ –¥–µ—Å–∫—Ç–æ–ø–µ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —à–∏—Ä–∏–Ω—É, –Ω–∞ –º–æ–±–∏–ª—å–Ω–æ–º - –Ω–∞ –≤–µ—Å—å —ç–∫—Ä–∞–Ω */
            max-width: 500px; 
            display: flex;
            flex-direction: column;
            background: linear-gradient(rgba(255, 222, 191, 0.9), rgba(255, 228, 204, 0.9)),
                        url('—Ñ–æ–Ω_2.jpeg') center/cover no-repeat;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        /* –ï—Å–ª–∏ —ç–∫—Ä–∞–Ω –±–æ–ª—å—à–æ–π, –¥–æ–±–∞–≤–ª—è–µ–º —Ä–∞–º–∫—É */
        @media (min-width: 501px) {
            .game-wrapper {
                height: 95dvh;
                border-radius: 30px;
                border: 6px solid #d2691e;
            }
        }

        /* ===== –®–ê–ü–ö–ê ===== */
        .header {
            flex: 0 0 auto;
            height: 90px;
            background: linear-gradient(165deg, #ffecd2, #fcdec2);
            border-bottom: 6px solid #c28a3b;
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            box-shadow: 0 5px 15px rgba(110, 55, 0, 0.2);
            z-index: 20;
            padding: 5px;
            border-radius: 0 0 25px 25px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255, 245, 220, 0.6);
            padding: 5px 10px;
            border-radius: 15px;
            border: 2px solid #d2691e;
            min-width: 70px;
        }

        .stat-label {
            font-size: 10px;
            color: #7b3f00;
            font-weight: 800;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 900;
            color: #a0522d;
        }

        /* –ñ–∏–∑–Ω–∏ */
        .lives-row {
            display: flex;
            gap: 4px;
            margin-top: 2px;
        }
        .life-dot {
            width: 14px;
            height: 14px;
            background: radial-gradient(circle at 30% 30%, #ffc068, #d41a1a);
            border-radius: 50%;
            border: 1px solid #9c5a2c;
            transition: 0.3s;
        }
        .life-dot.lost {
            background: #ccc;
            transform: scale(0.6);
            opacity: 0.5;
            border-color: #888;
        }

        /* ===== –ö–ù–û–ü–ö–ò –£–ü–†–ê–í–õ–ï–ù–ò–Ø ===== */
        .game-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: none; /* –ß—Ç–æ–±—ã –∫–ª–∏–∫–∏ –ø—Ä–æ—Ö–æ–¥–∏–ª–∏ —Å–∫–≤–æ–∑—å –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä */
            z-index: 50;
        }

        .control-btn {
            width: 55px;
            height: 55px;
            background: radial-gradient(circle at 30% 30%, #ffb347, #e68a2e);
            border: 3px solid #ffe28c;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            box-shadow: 0 6px 0 #9c5a2b, 0 8px 15px rgba(0,0,0,0.3);
            cursor: pointer;
            pointer-events: auto; /* –í–∫–ª—é—á–∞–µ–º –∫–ª–∏–∫–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫ */
            transition: transform 0.1s;
        }
        .control-btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #9c5a2b;
        }
        .control-btn.muted { filter: grayscale(1); }

        /* ===== CANVAS ===== */
        .canvas-container {
            flex: 1;
            position: relative;
            width: 100%;
            overflow: hidden;
            /* –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Ç–µ–Ω—å –¥–ª—è –≥–ª—É–±–∏–Ω—ã */
            box-shadow: inset 0 0 30px rgba(139, 69, 19, 0.2); 
            cursor: crosshair;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* ===== –ú–û–î–ê–õ–¨–ù–´–ï –û–ö–ù–ê ===== */
        .modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(60, 30, 10, 0.75);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.3s;
        }
        .hidden { display: none !important; }

        .modal-content {
            background: linear-gradient(145deg, #fff3e0, #ffecb3);
            padding: 25px;
            border-radius: 30px;
            width: 85%;
            max-width: 320px;
            text-align: center;
            border: 6px solid #ffa000;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            position: relative;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        .modal h1 { color: #d84315; font-size: 28px; margin-bottom: 10px; text-transform: uppercase; text-shadow: 1px 1px 0 #fff; }
        .modal p { color: #5d4037; font-size: 16px; margin-bottom: 15px; font-weight: 600; line-height: 1.4; }

        .big-btn {
            background: linear-gradient(to bottom, #ff9800, #f57c00);
            border: none;
            color: white;
            padding: 15px 30px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 50px;
            box-shadow: 0 6px 0 #e65100, 0 10px 10px rgba(0,0,0,0.2);
            width: 100%;
            margin-top: 10px;
        }
        .big-btn:active { transform: translateY(4px); box-shadow: 0 2px 0 #e65100; }

        /* –°–µ—Ç–∫–∞ –Ω–∞—á–∏–Ω–æ–∫ –≤ –º–µ–Ω—é */
        .flavors-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 15px 0;
            background: rgba(255,255,255,0.4);
            padding: 10px;
            border-radius: 15px;
        }
        .flavor-mini {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .flavor-icon {
            width: 35px; height: 35px;
            border-radius: 50%;
            background-size: cover;
            border: 2px solid #fff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            margin-bottom: 4px;
        }
        .flavor-text { font-size: 10px; font-weight: bold; color: #6d4c41; }
        
        .pause-stats p { font-size: 18px; margin: 8px 0; border-bottom: 1px dashed #d7ccc8; padding-bottom: 5px; }

    </style>
</head>
<body>

    <div class="sky-background"><div class="sun-rays"></div></div>

    <div class="game-wrapper">
        <div class="header">
            <div class="stat-item">
                <span class="stat-label">ü•û –°—á–µ—Ç</span>
                <span class="stat-value" id="score">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">‚ù§Ô∏è –ñ–∏–∑–Ω–∏</span>
                <div class="lives-row" id="lives-container"></div>
            </div>
            <div class="stat-item">
                <span class="stat-label">üèÜ –†–µ–∫–æ—Ä–¥</span>
                <span class="stat-value" id="high-score">0</span>
            </div>
        </div>

        <div class="canvas-container" id="canvas-container">
            <canvas id="gameCanvas"></canvas>
            
            <div id="modal" class="modal">
                <div class="modal-content">
                    <h1 id="modal-title">‚òÄÔ∏è –ú–ê–°–õ–ï–ù–ò–¶–ê</h1>
                    <p id="modal-desc">–°—Ç—Ä–µ–ª—è–π –±–ª–∏–Ω–∞–º–∏, —Å–æ–±–∏—Ä–∞–π –ø–æ 3 –≤ —Ä—è–¥!</p>
                    
                    <div id="flavors-section">
                        <div class="flavors-grid">
                            <div class="flavor-mini"><div class="flavor-icon" style="background-image: url('honey.png'); background-color: #ffd54f"></div><span class="flavor-text">–ú—ë–¥</span></div>
                            <div class="flavor-mini"><div class="flavor-icon" style="background-image: url('Strawberry.png'); background-color: #ef5350"></div><span class="flavor-text">–Ø–≥–æ–¥—ã</span></div>
                            <div class="flavor-mini"><div class="flavor-icon" style="background-image: url('milk.png'); background-color: #fff176"></div><span class="flavor-text">–°–≥—É—â.</span></div>
                            <div class="flavor-mini"><div class="flavor-icon" style="background-image: url('cheese.png'); background-color: #ffca28"></div><span class="flavor-text">–°—ã—Ä</span></div>
                            <div class="flavor-mini"><div class="flavor-icon" style="background-image: url('meat.png'); background-color: #8d6e63"></div><span class="flavor-text">–ú—è—Å–æ</span></div>
                            <div class="flavor-mini"><div class="flavor-icon" style="background: radial-gradient(circle, #333, #000);">üí£</div><span class="flavor-text">–ë–æ–º–±–∞</span></div>
                        </div>
                    </div>
                    
                    <button id="action-btn" class="big-btn">–ò–ì–†–ê–¢–¨</button>
                </div>
            </div>

            <div id="pauseModal" class="modal hidden">
                <div class="modal-content">
                    <h1>‚è∏ –ü–ê–£–ó–ê</h1>
                    <div class="pause-stats">
                        <p>–°—á–µ—Ç: <span id="pauseScore">0</span></p>
                        <p>–ñ–∏–∑–Ω–∏: <span id="pauseLives">0</span></p>
                    </div>
                    <button id="resumeBtn" class="big-btn" style="background: linear-gradient(#66bb6a, #43a047); box-shadow: 0 6px 0 #2e7d32;">–ü–†–û–î–û–õ–ñ–ò–¢–¨</button>
                </div>
            </div>
        </div>

        <div class="game-controls">
            <div id="pauseBtn" class="control-btn" style="font-size: 20px;">‚è∏</div>
            <div id="soundToggle" class="control-btn" style="font-size: 24px;">‚ô¨</div>
        </div>
    </div>

    <script>
    (function(){
        // === –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ===
        const canvas = document.getElementById('gameCanvas');
        const container = document.getElementById('canvas-container');
        const ctx = canvas.getContext('2d', { alpha: false });

        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let RADIUS, DIAMETER, SPEED;
        const COLUMNS_MOBILE = 9;  
        const MAX_LIVES = 5;

        // –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        const PANCAKE_IMAGES = ['honey.png', 'Strawberry.png', 'milk.png', 'cheese.png', 'meat.png'];
        const BOMB_IMAGE = 'bomb.png';
        
        const PANCAKE_TYPES = [
            { color: '#FFC107', border: '#FF6F00' },
            { color: '#FF5252', border: '#B71C1C' },
            { color: '#FFF59D', border: '#FBC02D' },
            { color: '#FFEB3B', border: '#F57F17' },
            { color: '#A1887F', border: '#5D4037' }
        ];
        const BOMB_TYPE = 99;

        // –ó–∞–≥—Ä—É–∑–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤
        let pancakeImgs = [];
        let bombImg = new Image();
        bombImg.src = BOMB_IMAGE;
        PANCAKE_IMAGES.forEach(src => { let img = new Image(); img.src = src; pancakeImgs.push(img); });

        // –°–æ—Å—Ç–æ—è–Ω–∏–µ
        let grid = [], particles = [], falling = [];
        let rows = 0, cols = 0, offsetX = 0;
        let score = 0, lives = MAX_LIVES, highScore = localStorage.getItem('blini_hs') || 0;
        let state = 'MENU';
        let shooter = { x: 0, y: 0, curr: 0, next: 0, ball: null };
        
        let isAiming = false;
        let aimAngle = -Math.PI / 2;
        let soundEnabled = true;

        // === –ó–í–£–ö ===
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function tryResumeAudio() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }
        
        function playTone(freq, type, duration) {
            if (!soundEnabled) return;
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValue(0.01, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            } catch(e) {}
        }

        const sounds = {
            shoot: () => playTone(600, 'sine', 0.15),
            pop: () => playTone(400, 'sine', 0.1),
            bomb: () => playTone(100, 'sawtooth', 0.3),
            miss: () => playTone(150, 'triangle', 0.3)
        };

        // === –†–ê–ó–ú–ï–†–´ –ò –ê–î–ê–ü–¢–ò–í ===
        function resize() {
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;

            cols = COLUMNS_MOBILE; 
            DIAMETER = Math.floor(canvas.width / cols);
            RADIUS = DIAMETER / 2;
            offsetX = (canvas.width - cols * DIAMETER) / 2;
            rows = Math.floor(canvas.height / DIAMETER) + 1;
            SPEED = canvas.height * 0.035; 

            shooter.x = canvas.width / 2;
            shooter.y = canvas.height - RADIUS * 2.5;
        }

        // === –õ–û–ì–ò–ö–ê ===
        function initGame() {
            tryResumeAudio();
            resize();
            score = 0; lives = MAX_LIVES; state = 'PLAYING';
            grid = []; particles = []; falling = [];
            for (let r = 0; r < rows; r++) grid[r] = new Array(cols).fill(null);
            for (let r = 0; r < 5; r++) createRow(r);

            shooter.curr = randType();
            shooter.next = randType();
            shooter.ball = null;
            
            updateUI();
            toggleModal('modal', false);
            toggleModal('pauseModal', false);
        }

        function createRow(r) {
            for (let c = 0; c < cols; c++) {
                if (Math.random() > 0.3) addBall(r, c, Math.random() < 0.05 ? BOMB_TYPE : randType());
            }
        }

        function addBall(r, c, type) {
            if (!grid[r]) return;
            grid[r][c] = { type: type, x: offsetX + c * DIAMETER + RADIUS, y: r * DIAMETER + RADIUS };
        }

        function randType() { return Math.floor(Math.random() * PANCAKE_IMAGES.length); }

        function update() {
            if (state !== 'PLAYING') return;

            // –®–∞—Ä
            if (shooter.ball) {
                let b = shooter.ball;
                const steps = 6;
                for (let i = 0; i < steps; i++) {
                    b.x += b.vx / steps;
                    b.y += b.vy / steps;

                    // –û—Ç—Å–∫–æ–∫ –æ—Ç —Å—Ç–µ–Ω
                    if (b.x < RADIUS) { b.x = RADIUS; b.vx *= -1; }
                    if (b.x > canvas.width - RADIUS) { b.x = canvas.width - RADIUS; b.vx *= -1; }
                    
                    // –ü–æ—Ç–æ–ª–æ–∫
                    if (b.y < RADIUS) { b.y = RADIUS; snapBall(b); return; }
                    
                    // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å –±–ª–∏–Ω–∞–º–∏
                    if (checkCollision(b)) return;
                }
                if (b.y > canvas.height + RADIUS) resetShot();
            }

            // –ê–Ω–∏–º–∞—Ü–∏–∏
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx; p.y += p.vy; p.life -= 0.03; p.vy += 0.5;
                if (p.life <= 0) particles.splice(i, 1);
            }
            for (let i = falling.length - 1; i >= 0; i--) {
                let f = falling[i];
                f.x += f.vx; f.y += f.vy; f.vy += 0.8; f.rot += f.rotSpd;
                if (f.y > canvas.height + DIAMETER) falling.splice(i, 1);
            }
        }

        function checkCollision(b) {
            let startR = Math.floor((b.y - RADIUS) / DIAMETER) - 1;
            let endR = startR + 3;
            for (let r = Math.max(0, startR); r < Math.min(rows, endR); r++) {
                for (let c = 0; c < cols; c++) {
                    let cell = grid[r]?.[c];
                    if (cell) {
                        let distSq = (b.x - cell.x)**2 + (b.y - cell.y)**2;
                        if (distSq < (DIAMETER * 0.9)**2) {
                            snapBall(b);
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function snapBall(b) {
            let c = Math.round((b.x - offsetX - RADIUS) / DIAMETER);
            let r = Math.round((b.y - RADIUS) / DIAMETER);
            c = Math.max(0, Math.min(c, cols - 1));
            r = Math.max(0, Math.min(r, rows - 1));

            if (grid[r] && grid[r][c]) r++; 
            if (r >= rows) return endGame();

            if (!grid[r]) grid[r] = new Array(cols).fill(null);
            addBall(r, c, b.type);
            
            let hitBomb = false;
            getNeighbors(r, c).forEach(n => {
                if (grid[n.r][n.c].type === BOMB_TYPE) { explode(n.r, n.c); hitBomb = true; }
            });

            if (!hitBomb) {
                if (b.type === BOMB_TYPE) explode(r, c);
                else {
                    let matches = findMatches(r, c, b.type, []);
                    if (matches.length >= 3) {
                        sounds.pop(); removeBalls(matches); score += matches.length * 10; checkFloating();
                    } else {
                        sounds.miss(); lives--;
                        if (lives <= 0) { addRow(); lives = MAX_LIVES; }
                    }
                }
            }
            resetShot(); updateUI(); checkLose();
        }

        function findMatches(r, c, type, visited) {
            let key = r + ',' + c;
            if (visited.includes(key)) return [];
            visited.push(key);
            let matches = [{r,c}];
            getNeighbors(r, c).forEach(n => {
                if (grid[n.r][n.c].type === type) matches = matches.concat(findMatches(n.r, n.c, type, visited));
            });
            return matches;
        }

        function getNeighbors(r, c) {
            return [[0,1], [0,-1], [1,0], [-1,0]]
                .map(d => ({r: r + d[0], c: c + d[1]}))
                .filter(n => n.r >= 0 && n.r < rows && n.c >= 0 && n.c < cols && grid[n.r] && grid[n.r][n.c]);
        }

        function removeBalls(list) {
            list.forEach(p => {
                if (grid[p.r][p.c]) {
                    createParticles(grid[p.r][p.c].x, grid[p.r][p.c].y, grid[p.r][p.c].type);
                    grid[p.r][p.c] = null;
                }
            });
        }

        function explode(r, c) {
            sounds.bomb();
            let range = 2;
            for (let i = r - range; i <= r + range; i++) {
                for (let j = c - range; j <= c + range; j++) {
                    if (i >= 0 && i < rows && j >= 0 && j < cols && grid[i] && grid[i][j]) {
                            createParticles(grid[i][j].x, grid[i][j].y, BOMB_TYPE);
                            grid[i][j] = null;
                            score += 5;
                    }
                }
            }
            checkFloating();
        }

        function checkFloating() {
            let connected = new Set();
            let queue = [];
            if (grid[0]) {
                for (let c = 0; c < cols; c++) if (grid[0][c]) { connected.add('0,' + c); queue.push({r:0, c:c}); }
            }
            while(queue.length > 0) {
                let curr = queue.shift();
                getNeighbors(curr.r, curr.c).forEach(n => {
                    let key = n.r + ',' + n.c;
                    if (!connected.has(key)) { connected.add(key); queue.push(n); }
                });
            }
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (grid[r][c] && !connected.has(r + ',' + c)) {
                        let cell = grid[r][c];
                        falling.push({ x: cell.x, y: cell.y, type: cell.type, vx: (Math.random()-0.5)*10, vy: -5, rot: 0, rotSpd: (Math.random()-0.5)*0.2 });
                        grid[r][c] = null; score += 20;
                    }
                }
            }
        }

        function addRow() {
            for (let r = rows - 2; r >= 0; r--) {
                grid[r+1] = grid[r];
                if (grid[r+1]) for(let c=0; c<cols; c++) if(grid[r+1][c]) grid[r+1][c].y += DIAMETER;
            }
            grid[0] = new Array(cols).fill(null);
            for (let c = 0; c < cols; c++) if(Math.random() > 0.2) addBall(0, c, Math.random()<0.05?BOMB_TYPE:randType());
        }

        function createParticles(x, y, type) {
            let color = type === BOMB_TYPE ? '#333' : PANCAKE_TYPES[type].color;
            for(let i=0; i<8; i++) particles.push({ x: x, y: y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 1, color: color });
        }

        function resetShot() {
            shooter.ball = null; shooter.curr = shooter.next; shooter.next = randType();
        }

        function checkLose() {
            for(let c=0; c<cols; c++) {
                let dangerRow = Math.floor((shooter.y - RADIUS * 2) / DIAMETER);
                if (grid[dangerRow] && grid[dangerRow][c]) { endGame(); return; }
            }
        }

        function endGame() {
            state = 'END';
            if (score > highScore) { highScore = score; localStorage.setItem('blini_hs', highScore); }
            document.getElementById('modal-title').innerText = "–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê";
            document.getElementById('modal-desc').innerHTML = `–°—á–µ—Ç: ${score}<br>–†–µ–∫–æ—Ä–¥: ${highScore}`;
            document.getElementById('flavors-section').style.display = 'none';
            document.getElementById('action-btn').innerText = "–ü–û–ü–†–û–ë–û–í–ê–¢–¨ –°–ù–û–í–ê";
            toggleModal('modal', true);
        }

        // === –û–¢–†–ò–°–û–í–ö–ê (–° –£–õ–£–ß–®–ï–ù–ù–´–ú –ü–†–ò–¶–ï–õ–û–ú) ===
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. –ë–ª–∏–Ω—ã –Ω–∞ –ø–æ–ª–µ
            for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) if (grid[r]?.[c]) drawPancake(grid[r][c].x, grid[r][c].y, grid[r][c].type);
            
            // 2. –ü–∞–¥–∞—é—â–∏–µ
            falling.forEach(f => { ctx.save(); ctx.translate(f.x, f.y); ctx.rotate(f.rot); drawPancake(0, 0, f.type); ctx.restore(); });
            
            // 3. –ß–∞—Å—Ç–∏—Ü—ã
            particles.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, RADIUS/3, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; });

            if (state !== 'MENU') {
                // === –ù–û–í–ê–Ø –¢–†–ê–ï–ö–¢–û–†–ò–Ø ===
                if (isAiming && !shooter.ball) {
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([10, 15]); // –ü—É–Ω–∫—Ç–∏—Ä

                    // –°–∏–º—É–ª—è—Ü–∏—è –ø–æ–ª–µ—Ç–∞ –¥–ª—è –ª–∏–Ω–∏–∏
                    let simX = shooter.x;
                    let simY = shooter.y;
                    let simAngle = aimAngle;
                    // –í–µ–∫—Ç–æ—Ä –¥–≤–∏–∂–µ–Ω–∏—è
                    let simVx = Math.cos(simAngle) * 15;
                    let simVy = Math.sin(simAngle) * 15;
                    
                    ctx.moveTo(simX, simY);

                    // –î–µ–ª–∞–µ–º 40 —à–∞–≥–æ–≤ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
                    for(let i=0; i<40; i++) {
                        simX += simVx;
                        simY += simVy;

                        // –û—Ç—Å–∫–æ–∫ –æ—Ç —Å—Ç–µ–Ω –≤ —Å–∏–º—É–ª—è—Ü–∏–∏
                        if (simX < RADIUS || simX > canvas.width - RADIUS) {
                            simVx = -simVx; 
                            simX += simVx; // –í–µ—Ä–Ω–µ–º —á—É—Ç—å –Ω–∞–∑–∞–¥, —á—Ç–æ–±—ã –Ω–µ –∑–∞—Å—Ç—Ä—è—Ç—å
                        }

                        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–∏ —Å —Å–µ—Ç–∫–æ–π –≤ —Å–∏–º—É–ª—è—Ü–∏–∏
                        let r = Math.floor((simY - RADIUS) / DIAMETER);
                        let c = Math.round((simX - offsetX - RADIUS) / DIAMETER);
                        if (r >= 0 && r < rows && c >= 0 && c < cols && grid[r]?.[c]) {
                            break; // –õ–∏–Ω–∏—è —É–ø–∏—Ä–∞–µ—Ç—Å—è –≤ –±–ª–∏–Ω
                        }
                        if (simY < RADIUS) break; // –õ–∏–Ω–∏—è —É–ø–∏—Ä–∞–µ—Ç—Å—è –≤ –ø–æ—Ç–æ–ª–æ–∫

                        ctx.lineTo(simX, simY);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // –°—Ç—Ä–µ–ª–æ–∫ –∏ —Å–ª–µ–¥—É—é—â–∏–π —à–∞—Ä
                if (!shooter.ball) drawPancake(shooter.x, shooter.y, shooter.curr);
                else drawPancake(shooter.ball.x, shooter.ball.y, shooter.ball.type);
                
                ctx.save(); ctx.translate(shooter.x + RADIUS * 2.5, shooter.y + RADIUS); ctx.scale(0.6, 0.6);
                drawPancake(0, 0, shooter.next); ctx.restore();
            }
        }

        function drawPancake(x, y, type) {
            let r = RADIUS - 1;
            if (type === BOMB_TYPE) {
                ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fillStyle = '#333'; ctx.fill();
                ctx.lineWidth = 2; ctx.strokeStyle = '#fff'; ctx.stroke();
                ctx.fillStyle = 'red'; ctx.font = `${r}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('üí£', x, y+2); return;
            }
            let img = pancakeImgs[type];
            if (img && img.complete && img.naturalWidth > 0) {
                ctx.save(); ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.clip();
                ctx.fillStyle = PANCAKE_TYPES[type].color; ctx.fill();
                ctx.drawImage(img, x-r, y-r, r*2, r*2);
                ctx.lineWidth = 3; ctx.strokeStyle = PANCAKE_TYPES[type].border; ctx.stroke(); ctx.restore();
            } else {
                ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fillStyle = PANCAKE_TYPES[type].color; ctx.fill();
                ctx.lineWidth = 3; ctx.strokeStyle = PANCAKE_TYPES[type].border; ctx.stroke();
            }
            ctx.beginPath(); ctx.arc(x - r*0.3, y - r*0.3, r*0.2, 0, Math.PI*2); ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.fill();
        }

        function loop() { update(); draw(); requestAnimationFrame(loop); }

        // === –£–ü–†–ê–í–õ–ï–ù–ò–ï ===
        function getTouchPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches && e.touches.length > 0) return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        function inputStart(pos) {
            tryResumeAudio();
            if (state !== 'PLAYING' || shooter.ball) return;
            isAiming = true;
            inputMove(pos);
        }

        function inputMove(pos) {
            if (!isAiming) return;
            let dx = pos.x - shooter.x;
            let dy = pos.y - shooter.y;
            if (dy > -20) dy = -20;
            aimAngle = Math.atan2(dy, dx);
        }

        function inputEnd() {
            if (isAiming) { isAiming = false; fire(); }
        }

        function fire() {
            sounds.shoot();
            shooter.ball = { x: shooter.x, y: shooter.y, type: shooter.curr, vx: Math.cos(aimAngle) * SPEED, vy: Math.sin(aimAngle) * SPEED };
        }

        canvas.addEventListener('touchstart', e => { e.preventDefault(); inputStart(getTouchPos(e)); }, {passive: false});
        canvas.addEventListener('touchmove', e => { e.preventDefault(); inputMove(getTouchPos(e)); }, {passive: false});
        canvas.addEventListener('touchend', e => { e.preventDefault(); inputEnd(); });
        canvas.addEventListener('mousedown', e => { inputStart(getTouchPos(e)); });
        window.addEventListener('mousemove', e => { inputMove(getTouchPos(e)); });
        window.addEventListener('mouseup', inputEnd);

        // UI
        document.getElementById('action-btn').onclick = initGame;
        document.getElementById('pauseBtn').onclick = (e) => {
            e.stopPropagation();
            if (state === 'PLAYING') { state = 'PAUSED'; document.getElementById('pauseScore').innerText = score; document.getElementById('pauseLives').innerText = lives; toggleModal('pauseModal', true); }
        };
        document.getElementById('resumeBtn').onclick = () => { state = 'PLAYING'; toggleModal('pauseModal', false); };
        document.getElementById('soundToggle').onclick = function(e) {
            e.stopPropagation(); soundEnabled = !soundEnabled; this.classList.toggle('muted'); tryResumeAudio();
        };

        function toggleModal(id, show) {
            const el = document.getElementById(id);
            if (show) el.classList.remove('hidden'); else el.classList.add('hidden');
        }

        function updateUI() {
            document.getElementById('score').innerText = score; document.getElementById('high-score').innerText = highScore;
            const lc = document.getElementById('lives-container'); lc.innerHTML = '';
            for(let i=0; i<MAX_LIVES; i++) { let d = document.createElement('div'); d.className = 'life-dot' + (i >= lives ? ' lost' : ''); lc.appendChild(d); }
        }
        
        window.addEventListener('resize', () => { if(state !== 'MENU') resize(); });

        resize();
        loop();
    })();
</script>
</body>
</html>


